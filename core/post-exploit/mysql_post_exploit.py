#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
POST_EXPLOIT_JSON = "{target}_{service}_post_exploit.json"
POST_EXPLOIT_MD = "{target}_{service}_post_exploit.md"
POST_EXPLOIT_REPORT = "{target}_{service}_post_exploit_report.txt"

def run_command(cmd: List[str], timeout: int = 300, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def test_mysql_connection(target: str, port: str, credentials: Dict) -> bool:
    """Test MySQL connection with provided credentials."""
    username = credentials.get("username", "root")
    password = credentials.get("password", "")
    
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e 'SELECT 1;'"
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e 'SELECT 1;'"
    
    output, success = run_command(cmd, timeout=30, shell=True)
    return success and "1" in output

def test_privilege_escalation(target: str, port: str, credentials: Dict) -> List[Dict]:
    """Test for privilege escalation opportunities."""
    results = []
    username = credentials.get("username", "root")
    password = credentials.get("password", "")
    
    # Test for SUPER privilege
    super_cmd = "SELECT User, Host, Super_priv FROM mysql.user WHERE Super_priv='Y';"
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{super_cmd}\""
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e \"{super_cmd}\""
    
    output, success = run_command(cmd, timeout=60, shell=True)
    if success and username in output:
        results.append({
            "type": "SUPER Privilege Found",
            "details": "User has SUPER privileges",
            "poc": f"mysql -h {target} -P {port} -u {username} -e \"{super_cmd}\"",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for FILE privilege
    file_cmd = "SELECT User, Host, File_priv FROM mysql.user WHERE File_priv='Y';"
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{file_cmd}\""
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e \"{file_cmd}\""
    
    output, success = run_command(cmd, timeout=60, shell=True)
    if success and username in output:
        results.append({
            "type": "FILE Privilege Found",
            "details": "User has FILE privileges for file operations",
            "poc": f"mysql -h {target} -P {port} -u {username} -e \"{file_cmd}\"",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_data_exfiltration(target: str, port: str, credentials: Dict) -> List[Dict]:
    """Test for data exfiltration opportunities."""
    results = []
    username = credentials.get("username", "root")
    password = credentials.get("password", "")
    
    # List all databases
    db_cmd = "SHOW DATABASES;"
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{db_cmd}\""
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e \"{db_cmd}\""
    
    output, success = run_command(cmd, timeout=60, shell=True)
    if success and output.strip():
        results.append({
            "type": "Database Enumeration",
            "details": "Successfully enumerated databases",
            "poc": f"mysql -h {target} -P {port} -u {username} -e \"{db_cmd}\"",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for sensitive tables
    sensitive_tables = ["users", "admin", "passwords", "credentials", "config"]
    for table in sensitive_tables:
        table_cmd = f"SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_NAME LIKE '%{table}%';"
        if password:
            cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{table_cmd}\""
        else:
            cmd = f"mysql -h {target} -P {port} -u {username} -e \"{table_cmd}\""
        
        output, success = run_command(cmd, timeout=60, shell=True)
        if success and table in output.lower():
            results.append({
                "type": "Sensitive Tables Found",
                "details": f"Found sensitive table: {table}",
                "poc": f"mysql -h {target} -P {port} -u {username} -e \"{table_cmd}\"",
                "output": output[:200] + "..." if len(output) > 200 else output
            })
    
    return results

def test_lateral_movement(target: str, port: str, credentials: Dict) -> List[Dict]:
    """Test for lateral movement opportunities."""
    results = []
    username = credentials.get("username", "root")
    password = credentials.get("password", "")
    
    # Test for network connectivity
    netstat_cmd = "SELECT @@hostname, @@port;"
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{netstat_cmd}\""
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e \"{netstat_cmd}\""
    
    output, success = run_command(cmd, timeout=60, shell=True)
    if success and output.strip():
        results.append({
            "type": "Network Information",
            "details": "Retrieved network information",
            "poc": f"mysql -h {target} -P {port} -u {username} -e \"{netstat_cmd}\"",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_persistence_mechanisms(target: str, port: str, credentials: Dict) -> List[Dict]:
    """Test for persistence mechanism opportunities."""
    results = []
    username = credentials.get("username", "root")
    password = credentials.get("password", "")
    
    # Test for triggers
    trigger_cmd = "SELECT TRIGGER_NAME, EVENT_MANIPULATION, ACTION_STATEMENT FROM information_schema.TRIGGERS;"
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{trigger_cmd}\""
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e \"{trigger_cmd}\""
    
    output, success = run_command(cmd, timeout=60, shell=True)
    if success and output.strip():
        results.append({
            "type": "Database Triggers Found",
            "details": "Database triggers discovered for persistence",
            "poc": f"mysql -h {target} -P {port} -u {username} -e \"{trigger_cmd}\"",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for stored procedures
    proc_cmd = "SELECT ROUTINE_NAME, ROUTINE_TYPE FROM information_schema.ROUTINES;"
    if password:
        cmd = f"mysql -h {target} -P {port} -u {username} -p'{password}' -e \"{proc_cmd}\""
    else:
        cmd = f"mysql -h {target} -P {port} -u {username} -e \"{proc_cmd}\""
    
    output, success = run_command(cmd, timeout=60, shell=True)
    if success and output.strip():
        results.append({
            "type": "Stored Procedures Found",
            "details": "Stored procedures discovered for persistence",
            "poc": f"mysql -h {target} -P {port} -u {username} -e \"{proc_cmd}\"",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def save_post_exploit_report(results: List[Dict], target: str, service: str, port: str) -> None:
    """Save post-exploitation report to JSON and Markdown."""
    json_path = OUTPUT_DIR / POST_EXPLOIT_JSON.format(target=target, service=service)
    md_path = OUTPUT_DIR / POST_EXPLOIT_MD.format(target=target, service=service)
    report_path = OUTPUT_DIR / POST_EXPLOIT_REPORT.format(target=target, service=service)
    
    metadata = {
        "target": target,
        "service": service,
        "port": port,
        "timestamp": time.strftime('%Y-%m-%d %H:%M:%S'),
        "post_exploitation_results": results
    }
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved post-exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# MySQL Post-Exploitation Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    for result in results:
        lines.append(f"## {result['type']}\n")
        lines.append(f"- **Details**: {result['details']}\n")
        lines.append(f"- **PoC**: `{result['poc']}`\n")
        lines.append(f"- **Output**: `{result['output']}`\n\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved post-exploit Markdown to {md_path}")
    
    # Save detailed report
    report_lines = [f"MySQL Post-Exploitation Report for {target}:{port}\n"]
    report_lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    report_lines.append("=" * 50 + "\n\n")
    
    for result in results:
        report_lines.append(f"Type: {result['type']}\n")
        report_lines.append(f"Details: {result['details']}\n")
        report_lines.append(f"PoC: {result['poc']}\n")
        report_lines.append(f"Output: {result['output']}\n")
        report_lines.append("-" * 30 + "\n\n")
    
    with report_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(report_lines))
    logger.info(f"Saved detailed report to {report_path}")

def post_exploit_target(target: str, service: str, port: str, exploit_data: Dict, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Perform comprehensive post-exploitation on MySQL service."""
    results = []
    
    logger.info(f"Starting MySQL post-exploitation on {target}:{port}")
    
    # Extract credentials from exploit data
    credentials = {"username": "root", "password": ""}
    for exploit in exploit_data.get("exploits", []):
        if "credentials" in exploit.get("details", "").lower():
            # Try to extract credentials from exploit details
            details = exploit.get("details", "")
            if ":" in details:
                parts = details.split(":")
                if len(parts) >= 2:
                    credentials["username"] = parts[0].strip()
                    credentials["password"] = parts[1].strip()
    
    # Test MySQL connection
    logger.info("Testing MySQL connection...")
    if not test_mysql_connection(target, port, credentials):
        logger.error("MySQL connection failed. Cannot proceed with post-exploitation.")
        return results
    
    # Test privilege escalation
    logger.info("Testing privilege escalation...")
    priv_results = test_privilege_escalation(target, port, credentials)
    results.extend(priv_results)
    
    # Test data exfiltration
    logger.info("Testing data exfiltration...")
    exfil_results = test_data_exfiltration(target, port, credentials)
    results.extend(exfil_results)
    
    # Test lateral movement
    logger.info("Testing lateral movement...")
    lateral_results = test_lateral_movement(target, port, credentials)
    results.extend(lateral_results)
    
    # Test persistence mechanisms
    logger.info("Testing persistence mechanisms...")
    persist_results = test_persistence_mechanisms(target, port, credentials)
    results.extend(persist_results)
    
    logger.info(f"MySQL post-exploitation completed. Found {len(results)} opportunities.")
    return results

def main():
    """Main function to parse arguments and run post-exploitation."""
    parser = argparse.ArgumentParser(description="MySQL Post-Exploitation Script")
    parser.add_argument("target", help="Target domain or IP")
    parser.add_argument("service", help="Service name (e.g., mysql)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["mysql", "python3"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Extract port from service name
    port = args.service.split("_")[-1] if "_" in args.service else "3306"
    
    # Create dummy exploit data for testing
    exploit_data = {
        "port": port,
        "exploits": [{"type": "MySQL Exploit", "details": "root:password"}]
    }

    # Run post-exploitation
    logger.info(f"Starting post-exploitation for {args.target}:{port}...")
    results = post_exploit_target(args.target, args.service, port, exploit_data, args.attacker_ip, args.attacker_port)

    # Save results
    save_post_exploit_report(results, args.target, args.service, port)
    logger.info("Post-exploitation complete.")

if __name__ == "__main__":
    main() 