#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
POST_EXPLOIT_JSON = "{target}_{service}_post_exploit.json"
POST_EXPLOIT_MD = "{target}_{service}_post_exploit.md"
POST_EXPLOIT_REPORT = "{target}_{service}_post_exploit_report.txt"

def run_command(cmd: List[str], timeout: int = 300, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def test_dns_zone_transfer(target: str, port: str) -> List[Dict]:
    """Test for DNS zone transfer vulnerabilities."""
    results = []
    
    # Test zone transfer with dig
    zone_transfer_cmd = f"dig @{target} AXFR"
    output, success = run_command(zone_transfer_cmd, timeout=60, shell=True)
    if success and "SOA" in output:
        results.append({
            "type": "DNS Zone Transfer",
            "details": "Zone transfer successful",
            "poc": f"dig @{target} AXFR",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for specific domains
    test_domains = ["example.com", "test.com", "local"]
    for domain in test_domains:
        zone_cmd = f"dig @{target} {domain} AXFR"
        output, success = run_command(zone_cmd, timeout=60, shell=True)
        if success and "SOA" in output:
            results.append({
                "type": "DNS Zone Transfer",
                "details": f"Zone transfer successful for {domain}",
                "poc": f"dig @{target} {domain} AXFR",
                "output": output[:200] + "..." if len(output) > 200 else output
            })
    
    return results

def test_dns_enumeration(target: str, port: str) -> List[Dict]:
    """Test for DNS enumeration opportunities."""
    results = []
    
    # Test for common record types
    record_types = ["A", "AAAA", "MX", "NS", "TXT", "CNAME", "PTR"]
    for record_type in record_types:
        enum_cmd = f"dig @{target} {target} {record_type}"
        output, success = run_command(enum_cmd, timeout=60, shell=True)
        if success and "ANSWER" in output:
            results.append({
                "type": "DNS Enumeration",
                "details": f"Found {record_type} records",
                "poc": f"dig @{target} {target} {record_type}",
                "output": output[:200] + "..." if len(output) > 200 else output
            })
    
    # Test for subdomain enumeration
    subdomain_cmd = f"dig @{target} {target} ANY"
    output, success = run_command(subdomain_cmd, timeout=60, shell=True)
    if success and "ANSWER" in output:
        results.append({
            "type": "DNS Enumeration",
            "details": "Found ANY records",
            "poc": f"dig @{target} {target} ANY",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_dns_data_exfiltration(target: str, port: str) -> List[Dict]:
    """Test for data exfiltration through DNS."""
    results = []
    
    # Test for DNS tunneling indicators
    tunnel_cmd = f"dig @{target} {target} TXT"
    output, success = run_command(tunnel_cmd, timeout=60, shell=True)
    if success and "TXT" in output:
        results.append({
            "type": "DNS Data Exfiltration",
            "details": "Found TXT records for data exfiltration",
            "poc": f"dig @{target} {target} TXT",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for reverse DNS lookup
    reverse_cmd = f"dig @{target} -x {target}"
    output, success = run_command(reverse_cmd, timeout=60, shell=True)
    if success and "PTR" in output:
        results.append({
            "type": "DNS Reverse Lookup",
            "details": "Reverse DNS lookup successful",
            "poc": f"dig @{target} -x {target}",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_dns_lateral_movement(target: str, port: str) -> List[Dict]:
    """Test for lateral movement through DNS."""
    results = []
    
    # Test for internal DNS servers
    internal_cmd = f"dig @{target} {target} NS"
    output, success = run_command(internal_cmd, timeout=60, shell=True)
    if success and "NS" in output:
        results.append({
            "type": "DNS Lateral Movement",
            "details": "Found internal DNS servers",
            "poc": f"dig @{target} {target} NS",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for DNS forwarding
    forward_cmd = f"dig @{target} google.com A"
    output, success = run_command(forward_cmd, timeout=60, shell=True)
    if success and "ANSWER" in output:
        results.append({
            "type": "DNS Forwarding",
            "details": "DNS forwarding enabled",
            "poc": f"dig @{target} google.com A",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def test_dns_persistence_mechanisms(target: str, port: str) -> List[Dict]:
    """Test for persistence mechanisms through DNS."""
    results = []
    
    # Test for DNS cache poisoning opportunities
    cache_cmd = f"dig @{target} {target} A +norecurse"
    output, success = run_command(cache_cmd, timeout=60, shell=True)
    if success and "ANSWER" in output:
        results.append({
            "type": "DNS Cache Poisoning",
            "details": "DNS cache poisoning possible",
            "poc": f"dig @{target} {target} A +norecurse",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    # Test for DNS amplification
    amp_cmd = f"dig @{target} {target} ANY +dnssec"
    output, success = run_command(amp_cmd, timeout=60, shell=True)
    if success and "ANSWER" in output:
        results.append({
            "type": "DNS Amplification",
            "details": "DNS amplification attack possible",
            "poc": f"dig @{target} {target} ANY +dnssec",
            "output": output[:200] + "..." if len(output) > 200 else output
        })
    
    return results

def save_post_exploit_report(results: List[Dict], target: str, service: str, port: str) -> None:
    """Save post-exploitation report to JSON and Markdown."""
    json_path = OUTPUT_DIR / POST_EXPLOIT_JSON.format(target=target, service=service)
    md_path = OUTPUT_DIR / POST_EXPLOIT_MD.format(target=target, service=service)
    report_path = OUTPUT_DIR / POST_EXPLOIT_REPORT.format(target=target, service=service)
    
    metadata = {
        "target": target,
        "service": service,
        "port": port,
        "timestamp": time.strftime('%Y-%m-%d %H:%M:%S'),
        "post_exploitation_results": results
    }
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved post-exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# DNS Post-Exploitation Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    for result in results:
        lines.append(f"## {result['type']}\n")
        lines.append(f"- **Details**: {result['details']}\n")
        lines.append(f"- **PoC**: `{result['poc']}`\n")
        lines.append(f"- **Output**: `{result['output']}`\n\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved post-exploit Markdown to {md_path}")
    
    # Save detailed report
    report_lines = [f"DNS Post-Exploitation Report for {target}:{port}\n"]
    report_lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    report_lines.append("=" * 50 + "\n\n")
    
    for result in results:
        report_lines.append(f"Type: {result['type']}\n")
        report_lines.append(f"Details: {result['details']}\n")
        report_lines.append(f"PoC: {result['poc']}\n")
        report_lines.append(f"Output: {result['output']}\n")
        report_lines.append("-" * 30 + "\n\n")
    
    with report_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(report_lines))
    logger.info(f"Saved detailed report to {report_path}")

def post_exploit_target(target: str, service: str, port: str, exploit_data: Dict, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Perform comprehensive post-exploitation on DNS service."""
    results = []
    
    logger.info(f"Starting DNS post-exploitation on {target}:{port}")
    
    # Test DNS zone transfer
    logger.info("Testing DNS zone transfer...")
    zone_results = test_dns_zone_transfer(target, port)
    results.extend(zone_results)
    
    # Test DNS enumeration
    logger.info("Testing DNS enumeration...")
    enum_results = test_dns_enumeration(target, port)
    results.extend(enum_results)
    
    # Test data exfiltration
    logger.info("Testing data exfiltration...")
    exfil_results = test_dns_data_exfiltration(target, port)
    results.extend(exfil_results)
    
    # Test lateral movement
    logger.info("Testing lateral movement...")
    lateral_results = test_dns_lateral_movement(target, port)
    results.extend(lateral_results)
    
    # Test persistence mechanisms
    logger.info("Testing persistence mechanisms...")
    persist_results = test_dns_persistence_mechanisms(target, port)
    results.extend(persist_results)
    
    logger.info(f"DNS post-exploitation completed. Found {len(results)} opportunities.")
    return results

def main():
    """Main function to parse arguments and run post-exploitation."""
    parser = argparse.ArgumentParser(description="DNS Post-Exploitation Script")
    parser.add_argument("target", help="Target domain or IP")
    parser.add_argument("service", help="Service name (e.g., dns)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["dig", "python3"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Extract port from service name
    port = args.service.split("_")[-1] if "_" in args.service else "53"
    
    # Create dummy exploit data for testing
    exploit_data = {
        "port": port,
        "exploits": [{"type": "DNS Exploit", "details": "Zone transfer vulnerability"}]
    }

    # Run post-exploitation
    logger.info(f"Starting post-exploitation for {args.target}:{port}...")
    results = post_exploit_target(args.target, args.service, port, exploit_data, args.attacker_ip, args.attacker_port)

    # Save results
    save_post_exploit_report(results, args.target, args.service, port)
    logger.info("Post-exploitation complete.")

if __name__ == "__main__":
    main() 