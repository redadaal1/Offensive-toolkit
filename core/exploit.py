#!/usr/bin/env python3
import subprocess
import concurrent.futures
import json
import re
from pathlib import Path
from typing import Dict, List, Set
import logging
import importlib
import argparse
import sys
from datetime import datetime

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs").absolute()
SUMMARY = OUTPUT_DIR / "exploitation_summary.md"
EXPLOIT_DIR = Path(__file__).parent / "exploit"
# Changed to string template for clarity
COMBINED_JSON = "{target}_combined_report.json"

def run_command(cmd: List[str], timeout: int = None) -> tuple:
    """Run a command and return its output and success status."""
    logger.info(f"Running command: {' '.join(cmd)}")
    try:
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout,
            check=True
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {' '.join(cmd)} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {' '.join(cmd)}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Unexpected error running command {' '.join(cmd)}: {e}")
        return str(e), False

def clean_ansi_codes(text: str) -> str:
    """Remove ANSI escape codes from text."""
    ansi_pattern = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
    return ansi_pattern.sub('', text)

def detect_exploitation_success(output: str, exploit_type: str = "general") -> bool:
    """Standardized success detection for different exploitation types."""
    output_lower = output.lower()
    
    # Common success patterns
    success_patterns = [
        "meterpreter session",
        "session opened",
        "command shell session",
        "shell session",
        "exploit completed",
        "sessions -i",
        "uid:",
        "root@",
        "backdoor service has been spawned",
        "command shell session 1 opened",
        "found shell",
        "shell session 1 opened",
        "meterpreter session 1 opened",
        "session 1 opened",
        "login:",
        "password:",
        "230 login successful",
        "220 welcome",
        "anonymous access granted",
        "file uploaded successfully",
        "transfer complete",
        "226 transfer complete",
        "database dumped",
        "sql injection successful",
        "xss payload executed",
        "lfi vulnerability confirmed",
        "rce achieved",
        "reverse shell connected",
        "privilege escalation successful",
        "root access obtained"
    ]
    
    # Failure patterns to avoid false positives
    failure_patterns = [
        "exploit failed",
        "exploit completed, but no session was created",
        "no session was created",
        "exploit failed:",
        "[-]",
        "failed to exploit",
        "connection refused",
        "timeout",
        "authentication failed",
        "access denied",
        "login failed",
        "invalid credentials",
        "permission denied"
    ]
    
    # Service-specific patterns
    service_patterns = {
        "ftp": ["230", "220", "drwx", "total", "anonymous access", "login successful"],
        "ssh": ["uid:", "root@", "shell", "bash", "sh", "login successful"],
        "http": ["sql injection", "xss", "lfi", "rce", "file uploaded", "shell access"],
        "telnet": ["uid:", "root@", "shell", "login successful"],
        "smb": ["access granted", "share accessible", "file access"],
        "mysql": ["database", "table", "dump", "access granted"],
        "postgresql": ["database", "table", "dump", "access granted"],
        "vnc": ["vnc server", "authentication bypass", "access granted"]
    }
    
    # Check for success patterns
    has_success = any(pattern in output_lower for pattern in success_patterns)
    
    # Check for service-specific patterns
    if exploit_type in service_patterns:
        has_service_success = any(pattern in output_lower for pattern in service_patterns[exploit_type])
        has_success = has_success or has_service_success
    
    # Check for failure patterns
    has_failure = any(pattern in output_lower for pattern in failure_patterns)
    
    # Return success only if success patterns found and no failure patterns
    return has_success and not has_failure

def check_recon_completion(target: str) -> bool:
    """Check if recon.py has completed by verifying output files."""
    combined_json = OUTPUT_DIR / COMBINED_JSON.format(target=target)  # Construct Path here
    scan_files = [
        OUTPUT_DIR / f"{target}_tcp_fast.txt",
        OUTPUT_DIR / f"{target}_tcp_full.txt",
        OUTPUT_DIR / f"{target}_udp_fast.txt"
    ]
    
    if not combined_json.exists():
        logger.error(f"Combined report not found: {combined_json}. Run recon.py first.")
        return False
    
    scan_exists = any(f.exists() for f in scan_files)
    if not scan_exists:
        logger.error(f"No scan files found for {target}. Expected at least one of: {', '.join(str(f) for f in scan_files)}")
        return False
    
    logger.info(f"Confirmed recon.py completion: {combined_json} exists")
    return True

# Rest of the script remains unchanged
def get_services_from_outputs(target: str) -> Dict[str, int]:
    """Extract services and their ports from combined JSON."""
    services = {}
    
    combined_json = OUTPUT_DIR / COMBINED_JSON.format(target=target)
    try:
        with combined_json.open("r", encoding='utf-8') as f:
            data = json.load(f)
        for svc_key, svc_data in data.get("services", {}).items():
            port = svc_data.get("port", 0)
            if port:
                svc_name = svc_key.split("_")[0].lower()
                services[svc_name] = port
        logger.info(f"Services from {combined_json}: {services}")
    except Exception as e:
        logger.error(f"Error processing {combined_json}: {e}")
    
    return services

def get_exploit_scripts() -> List[Path]:
    """Get list of Python scripts in core/exploit directory."""
    if not EXPLOIT_DIR.exists():
        EXPLOIT_DIR.mkdir(exist_ok=True)
        logger.info(f"Created exploit directory: {EXPLOIT_DIR}")
    
    scripts = list(EXPLOIT_DIR.glob("*.py"))
    logger.info(f"Found {len(scripts)} exploit scripts: {', '.join(s.name for s in scripts)}")
    return scripts

def map_services_to_scripts(services: Set[str]) -> Dict[str, List[Path]]:
    """Map detected services to relevant exploit scripts."""
    service_to_scripts = {
        "http": ["http_exploit.py"],
        "ftp": ["ftp_exploit.py"],
        "ssh": ["ssh_exploit.py"],
        "smtp": ["smtp_exploit.py"],
        "mysql": ["mysql_exploit.py"],
        "smb": ["smb_exploit.py"],
        "telnet": ["telnet_exploit.py"],
        "dns": ["dns_exploit.py"],
        "vnc": ["vnc_exploit.py"],
        "snmp": ["snmp_exploit.py"],
        "postgresql": ["postgresql_exploit.py"],
        "ajp": ["ajp_exploit.py"],
        "java-rmi": ["java_rmi_exploit.py"],
        "rpc": ["rpc_exploit.py"],
        "irc": ["irc_exploit.py"],
        "netbios": ["netbios_exploit.py"],
        "nfs": ["nfs_exploit.py"],
        "mssql": ["mssql_exploit.py"],
        "tns": ["tns_exploit.py"],
        "bindshell": ["backdoor_exploit.py"]
    }
    
    available_scripts = get_exploit_scripts()
    script_map = {}
    
    for service in services:
        service_lower = service.lower()
        if service_lower in service_to_scripts:
            for script_name in service_to_scripts[service_lower]:
                script_path = EXPLOIT_DIR / script_name
                if script_path in available_scripts:
                    if service_lower not in script_map:
                        script_map[service_lower] = []
                    script_map[service_lower].append(script_path)
                    logger.info(f"Mapped {service} to {script_name}")
    
    return script_map

def run_exploit_script(script_path: Path, target: str, port: int, attacker_ip: str, attacker_port: str, use_rockyou: bool = False) -> Dict:
    """Run an exploit script with required arguments and improved error handling."""
    script_name = script_path.stem
    logger.info(f"Starting exploitation for {script_name} on port {port}")
    
    try:
        cmd = [
            "python3",
            str(script_path),
            target,
            "--port", str(port),
            "--attacker-ip",
            attacker_ip,
            "--attacker-port",
            attacker_port,
            "--no-confirm"
        ]
        
        # Add rockyou flag for all scripts that support it
        if use_rockyou:
            cmd.append("--use-rockyou")
        
        output, success = run_command(cmd)
        output = clean_ansi_codes(output)
        
        # Enhanced error handling and logging
        if not success:
            logger.error(f"Exploit script {script_name} failed with output: {output[:200]}...")
        else:
            logger.info(f"Exploit script {script_name} completed successfully")
        
        # Check for exploit results
        exploit_json = OUTPUT_DIR / f"{target}_{script_name.replace('_exploit', '')}_exploit.json"
        exploit_data = {}
        if exploit_json.exists():
            try:
                with exploit_json.open("r", encoding='utf-8') as f:
                    exploit_data = json.load(f)
                logger.info(f"Loaded exploit results for {script_name}")
            except Exception as e:
                logger.error(f"Error loading exploit results for {script_name}: {e}")
        
        return {
            "script": script_name,
            "output": output,
            "success": success,
            "exploit_data": exploit_data,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Unexpected error running {script_name}: {e}")
        return {
            "script": script_name,
            "output": f"Error: {str(e)}",
            "success": False,
            "exploit_data": {},
            "timestamp": datetime.now().isoformat()
        }

def aggregate_results(target: str, results: List[Dict]) -> str:
    """Aggregate results into a markdown summary with improved data handling."""
    lines = [f"# Exploitation Summary for {target} (Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')})\n"]
    
    successful_exploits = 0
    total_exploits = len(results)
    
    for result in results:
        script = result["script"]
        success = result["success"]
        output = result["output"]
        exploit_data = result.get("exploit_data", {})
        timestamp = result.get("timestamp", "Unknown")
        
        if success:
            successful_exploits += 1
        
        lines.append(f"## {script.replace('_', ' ').title()}\n")
        lines.append(f"- **Status**: {'Success' if success else 'Failed'}\n")
        lines.append(f"- **Timestamp**: {timestamp}\n")
        
        # Add exploit data summary if available
        if exploit_data and isinstance(exploit_data, dict):
            successful_exploits_count = len(exploit_data.get("successful_exploits", []))
            lines.append(f"- **Exploits Found**: {successful_exploits_count}\n")
            
            # List successful exploits
            if successful_exploits_count > 0:
                lines.append("### Successful Exploits\n")
                for exploit in exploit_data.get("successful_exploits", [])[:3]:  # Show first 3
                    lines.append(f"- **{exploit.get('type', 'Unknown')}**: {exploit.get('details', 'No details')}\n")
        
        lines.append("### Output\n")
        lines.append("```\n" + (output[:500] + "..." if len(output) > 500 else output) + "\n```\n")
        
        lines.append("- **Next Steps**:")
        if success:
            lines.append("  - Check listener (`nc -lvp 4444`) for reverse shells.")
            lines.append("  - Review exploit JSON files in outputs/ for details.")
            lines.append("  - Run post-exploitation scripts for further access.")
            lines.append("  - Verify downloaded files in `outputs/` (e.g., passwd, shadow).")
        else:
            lines.append("  - Review errors in output above.")
            lines.append("  - Ensure dependencies (hydra, metasploit-framework, nmap, gcc) are installed.")
            lines.append("  - Verify target is reachable: `ping <target>`.")
            lines.append("  - Check if reconnaissance data exists for this service.")
        
        lines.append("\n")
    
    # Add summary statistics
    lines.insert(1, f"- **Total Scripts**: {total_exploits}\n")
    lines.insert(2, f"- **Successful**: {successful_exploits}\n")
    lines.insert(3, f"- **Failed**: {total_exploits - successful_exploits}\n")
    lines.insert(4, f"- **Success Rate**: {(successful_exploits/total_exploits*100):.1f}%\n\n")
    
    return "\n".join(lines)

def main():
    """Main function to orchestrate exploit scripts based on recon.py output."""
    parser = argparse.ArgumentParser(description="Automated Exploitation Orchestrator")
    parser.add_argument("target", help="Target domain or IP (e.g., 192.168.1.35)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute-forcing in HTTP exploits")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    parser.add_argument("--services", help="Comma-separated list of services to exploit (e.g., http,ssh,ftp)")
    args = parser.parse_args()

    # Legal warning (skip if --no-confirm is used)
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only. Unauthorized exploitation is illegal and unethical.")
        response = input("Do you want to continue? (y/N): ")
        if response.lower() != 'y':
            logger.info("Exploitation cancelled by user.")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["hydra", "msfconsole", "nmap", "gcc"]:
        if not subprocess.run(["which", tool], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).returncode == 0:
            logger.error(f"{tool} not found. Install it (e.g., sudo apt install {tool.replace('msfconsole', 'metasploit-framework')}).")
            sys.exit(1)

    # Ensure output directory exists
    OUTPUT_DIR.mkdir(exist_ok=True)

    # Check recon.py completion
    if not check_recon_completion(args.target):
        logger.error("recon.py has not completed. Run `python3 recon.py <target>` first.")
        sys.exit(1)

    # Get services from outputs
    all_services = get_services_from_outputs(args.target)
    if not all_services:
        logger.error("No services detected in outputs. Ensure recon.py ran successfully.")
        sys.exit(1)

    # Filter services if specific services are requested
    if args.services:
        selected_services = [s.strip().lower() for s in args.services.split(",")]
        logger.info(f"Filtering services to: {', '.join(selected_services)}")
        services = {}
        for service in all_services:
            if service.lower() in selected_services:
                services[service] = all_services[service]
                logger.info(f"Including {service} (requested) with port {all_services[service]}")
            else:
                logger.info(f"Skipping {service} (not requested)")
        logger.info(f"Filtered to {len(services)} services: {', '.join(services.keys())}")
    else:
        services = all_services
        logger.info(f"Using all {len(services)} detected services: {', '.join(services.keys())}")

    # Map services to scripts
    script_map = map_services_to_scripts(services.keys())
    scripts_to_run = []
    for svc, scripts in script_map.items():
        if svc in services:
            port = services[svc]
            for script in scripts:
                scripts_to_run.append((script, port))
    
    if not scripts_to_run:
        logger.error(f"No exploit scripts found for services: {', '.join(services.keys())}")
        sys.exit(1)

    # Run exploit scripts sequentially
    logger.info(f"Running {len(scripts_to_run)} exploit scripts for {args.target}")
    results = []
    
    for script, port in scripts_to_run:
        logger.info(f"Starting {script.name} on port {port}...")
        try:
            result = run_exploit_script(
                script,
                args.target,
                port,
                args.attacker_ip,
                args.attacker_port,
                args.use_rockyou
            )
            results.append(result)
            logger.info(f"Completed {result['script']}: {'Success' if result['success'] else 'Failed'}")
        except Exception as e:
            logger.error(f"Error running {script.name}: {e}")
            results.append({
                "script": script.stem,
                "output": str(e),
                "success": False,
                "metadata": {},
                "report": ""
            })

    # Save summary
    summary_content = aggregate_results(args.target, results)
    with SUMMARY.open("w", encoding='utf-8') as f:
        f.write(summary_content)
    logger.info(f"Report written to {SUMMARY}")

if __name__ == "__main__":
    main()