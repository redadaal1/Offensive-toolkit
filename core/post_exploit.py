#!/usr/bin/env python3
import subprocess
import concurrent.futures
import json
import re
from pathlib import Path
from typing import Dict, List, Set
import logging
import argparse
import sys
from datetime import datetime

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs").absolute()
POST_EXPLOIT_DIR = Path(__file__).parent / "post-exploit"
SUMMARY = OUTPUT_DIR / "post_exploitation_summary.md"
POST_EXPLOIT_METADATA = OUTPUT_DIR / "post_exploitation_metadata.json"

def run_command(cmd: List[str], timeout: int = None) -> tuple:
    """Run a command and return its output and success status."""
    logger.info(f"Running command: {' '.join(cmd)}")
    try:
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout,
            check=True
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {' '.join(cmd)} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {' '.join(cmd)}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Unexpected error running command {' '.join(cmd)}: {e}")
        return str(e), False

def clean_ansi_codes(text: str) -> str:
    """Remove ANSI escape codes from text."""
    ansi_pattern = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
    return ansi_pattern.sub('', text)

def check_exploitation_completion(target: str) -> bool:
    """Check if exploitation has completed by verifying exploit output files."""
    exploit_files = list(OUTPUT_DIR.glob(f"{target}_*_exploit.json"))
    if not exploit_files:
        logger.warning(f"No exploit output files found for {target}. This is normal if exploitation failed or no vulnerabilities were found.")
        return True  # Allow post-exploitation to continue even without exploit files
    
    logger.info(f"Found {len(exploit_files)} exploit output files for {target}")
    return True

def get_successful_exploits(target: str) -> Dict[str, Dict]:
    """Extract successful exploits from output files."""
    successful_exploits = {}
    
    exploit_files = list(OUTPUT_DIR.glob(f"{target}_*_exploit.json"))
    for exploit_file in exploit_files:
        try:
            with exploit_file.open("r", encoding='utf-8') as f:
                data = json.load(f)
            
            # A more robust way to get the service name, accommodating different formats
            service = data.get("service")
            if not service:
                # Fallback to parsing from filename if not in JSON
                # Expected pattern: {target}_{service}_exploit.json
                parts = exploit_file.stem.split('_')
                if len(parts) >= 3 and parts[-1] == "exploit":
                    service = parts[-2]
                elif len(parts) >= 2:
                    service = parts[1]
                else:
                    service = exploit_file.stem
            # Normalize common aliases
            alias = {"https": "http", "ssl-http": "http", "http-burp": "http", "microsoft-ds": "smb", "msrpc": "rpc"}
            service = alias.get(service.lower(), service.lower())

            # Derive/normalize port if missing
            port_value = data.get("port")
            if (not port_value) and isinstance(data.get("target"), str) and ":" in data["target"]:
                try:
                    maybe_port = data["target"].rsplit(":", 1)[1]
                    if str(maybe_port).isdigit():
                        port_value = int(maybe_port)
                except Exception:
                    port_value = None

            if data.get("successful_exploits"):
                successful_exploits[service] = {
                    "file": str(exploit_file),
                    "data": data,
                    "port": port_value if port_value else "unknown",
                    "exploits": data.get("successful_exploits", [])
                }
                logger.info(f"Found successful exploits for {service}: {len(data['successful_exploits'])} exploits")
        except Exception as e:
            logger.error(f"Error reading {exploit_file}: {e}")
    
    return successful_exploits

def get_post_exploit_scripts() -> List[Path]:
    """Get list of Python scripts in core/post-exploit directory."""
    if not POST_EXPLOIT_DIR.exists():
        POST_EXPLOIT_DIR.mkdir(exist_ok=True)
        logger.info(f"Created post-exploit directory: {POST_EXPLOIT_DIR}")
    
    scripts = list(POST_EXPLOIT_DIR.glob("*.py"))
    logger.info(f"Found {len(scripts)} post-exploit scripts: {', '.join(s.name for s in scripts)}")
    return scripts

def map_services_to_post_exploit_scripts(services: Set[str]) -> Dict[str, List[Path]]:
    """Map detected services to relevant post-exploit scripts."""
    service_to_scripts = {
        "http": ["http_post_exploit.py"],
        "ftp": ["ftp_post_exploit.py"],
        "ssh": ["ssh_post_exploit.py"],
        "smtp": ["smtp_post_exploit.py"],
        "mysql": ["mysql_post_exploit.py"],
        "smb": ["smb_post_exploit.py"],
        "telnet": ["telnet_post_exploit.py"],
        "dns": ["dns_post_exploit.py"],
        "vnc": ["vnc_post_exploit.py"],
        "snmp": ["snmp_post_exploit.py"],
        "postgresql": ["postgresql_post_exploit.py"],
        "ajp": ["ajp_post_exploit.py"],
        "java-rmi": ["java_rmi_post_exploit.py"],
        "rpc": ["rpc_post_exploit.py"],
        "irc": ["irc_post_exploit.py"],
        "netbios": ["netbios_post_exploit.py"],
        "nfs": ["nfs_post_exploit.py"],
        "mssql": ["mssql_post_exploit.py"],
        "tns": ["tns_post_exploit.py"]
    }
    
    script_map = {}
    for svc in services:
        scripts = service_to_scripts.get(svc, [])
        script_map[svc] = [POST_EXPLOIT_DIR / s for s in scripts if (POST_EXPLOIT_DIR / s).exists()]
        if scripts and not script_map[svc]:
            logger.warning(f"No post-exploit scripts found for {svc}: Expected {', '.join(scripts)}")
        elif script_map[svc]:
            logger.info(f"Mapped {svc} to post-exploit scripts: {', '.join(s.name for s in script_map[svc])}")
    return script_map

def run_post_exploit_script(script_path: Path, target: str, service: str, exploit_data: Dict, attacker_ip: str, attacker_port: str) -> Dict:
    """Run a post-exploit script with required arguments and improved error handling."""
    script_name = script_path.stem
    logger.info(f"Starting post-exploitation for {service} using {script_name}")
    
    try:
        cmd = [
            "python3",
            str(script_path),
            target,
        ]
        
        # Dynamically add port if available and numeric
        if "port" in exploit_data:
            try:
                port_val = str(exploit_data["port"]).strip()
                if port_val.isdigit():
                    cmd.extend(["--port", port_val])
            except Exception:
                pass

        # Add attacker info for scripts that need it
        cmd.extend(["--attacker-ip", attacker_ip, "--attacker-port", attacker_port, "--no-confirm"])
        
        output, success = run_command(cmd, timeout=None)
        # Fallback: some post-exploit scripts (e.g., HTTP) do not accept --port
        if (not success) and ("unrecognized arguments: --port" in (output or "")):
            logger.info(f"{script_name} does not accept --port, retrying without it")
            try:
                # remove '--port' and the value following it
                if "--port" in cmd:
                    idx = cmd.index("--port")
                    # drop --port and the next arg if present
                    cmd = cmd[:idx] + cmd[idx+2:]
                output, success = run_command(cmd, timeout=None)
            except Exception:
                pass
        output = clean_ansi_codes(output)
        
        # Enhanced error handling and logging
        if not success:
            logger.error(f"Post-exploit script {script_name} failed with output: {output[:200]}...")
        else:
            logger.info(f"Post-exploit script {script_name} completed successfully")
        
        # Check for post-exploitation results
        post_exploit_json = OUTPUT_DIR / f"{target}_{exploit_data.get('port', service)}_ssh_post_exploit.json"
        post_exploit_data = {}
        if post_exploit_json.exists():
            try:
                with post_exploit_json.open("r", encoding='utf-8') as f:
                    post_exploit_data = json.load(f)
                logger.info(f"Loaded post-exploitation results for {script_name}")
            except Exception as e:
                logger.error(f"Error loading post-exploitation results for {script_name}: {e}")
        
        return {
            "script": script_name,
            "service": service,
            "output": output,
            "success": success,
            "post_exploit_data": post_exploit_data,
            "exploit_data": exploit_data,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Unexpected error running {script_name}: {e}")
        return {
            "script": script_name,
            "service": service,
            "output": f"Error: {str(e)}",
            "success": False,
            "post_exploit_data": {},
            "exploit_data": exploit_data,
            "timestamp": datetime.now().isoformat()
        }

def aggregate_post_exploit_results(target: str, results: List[Dict]) -> str:
    """Aggregate post-exploitation results into a markdown summary."""
    lines = [f"# Post-Exploitation Summary for {target} (Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')})\n"]
    
    for result in results:
        script = result["script"]
        service = result["service"]
        success = result["success"]
        output = result["output"]
        metadata = result.get("metadata", result.get("post_exploit_data", {}))
        report = result.get("report", "")
        exploit_data = result["exploit_data"]
        
        lines.append(f"## {service.upper()} Post-Exploitation ({script})\n")
        lines.append(f"- **Status**: {'Success' if success else 'Failed'}\n")
        lines.append(f"- **Port**: {exploit_data.get('port', 'unknown')}\n")
        lines.append(f"- **Exploits Found**: {len(exploit_data.get('exploits', []))}\n")
        
        lines.append("### Original Exploits\n")
        for exploit in exploit_data.get('exploits', []):
            if 'type' in exploit:
                lines.append(f"- **{exploit['type']}**: {exploit.get('details', 'N/A')}\n")
        
        lines.append("### Post-Exploitation Output\n")
        lines.append("```\n" + (output[:1000] + "..." if len(output) > 1000 else output) + "\n```\n")
        
        if metadata:
            lines.append("### Metadata\n")
            lines.append("```json\n" + json.dumps(metadata, indent=2)[:500] + "..." + "\n```\n")
        
        if report:
            lines.append("### Report\n")
            lines.append("```\n" + (report[:500] + "..." if len(report) > 500 else report) + "\n```\n")
        
        lines.append("- **Next Steps**:")
        if success:
            lines.append("  - Review post-exploitation findings.")
            lines.append("  - Check for privilege escalation opportunities.")
            lines.append("  - Document persistence mechanisms.")
            lines.append("  - Verify data exfiltration results.")
        else:
            lines.append("  - Review errors in output above.")
            lines.append("  - Check if target is still accessible.")
            lines.append("  - Verify exploit conditions still exist.")
        
        lines.append("\n")
    
    return "\n".join(lines)

def main():
    """Main function."""
    parser = argparse.ArgumentParser(description="Automated Post-Exploitation Orchestrator")
    parser.add_argument("target", help="Target domain or IP (e.g., 192.168.1.35)")
    parser.add_argument("--port", type=int, help="Target port for the specific service script")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    parser.add_argument("--services", help="Comma-separated list of services for post-exploitation (e.g., http,ssh,ftp)")
    args = parser.parse_args()

    # Legal warning (skip if --no-confirm is used)
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only. Unauthorized post-exploitation is illegal and unethical.")
        confirm = input("[?] Proceed with post-exploitation? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["nmap", "msfconsole", "python3"]:
        if not subprocess.run(["which", tool], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).returncode == 0:
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Ensure output directory exists
    OUTPUT_DIR.mkdir(exist_ok=True)

    # Check exploitation completion
    if not check_exploitation_completion(args.target):
        logger.error("Exploitation has not completed. Run `python3 -m core.exploit <target>` first.")
        sys.exit(1)

    # Get successful exploits
    all_successful_exploits = get_successful_exploits(args.target)
    if not all_successful_exploits:
        logger.error("No successful exploits found. Run exploitation first.")
        sys.exit(1)

    # Filter services if specific services are requested
    if args.services:
        selected_services = [s.strip().lower() for s in args.services.split(",")]
        logger.info(f"Filtering post-exploitation services to: {', '.join(selected_services)}")
        successful_exploits = {}
        for service, exploit_data in all_successful_exploits.items():
            if service.lower() in selected_services:
                successful_exploits[service] = exploit_data
                logger.info(f"Including {service} for post-exploitation (requested)")
            else:
                logger.info(f"Skipping {service} for post-exploitation (not requested)")
        logger.info(f"Filtered to {len(successful_exploits)} services for post-exploitation: {', '.join(successful_exploits.keys())}")
    else:
        successful_exploits = all_successful_exploits
        logger.info(f"Using all {len(successful_exploits)} successful exploits for post-exploitation: {', '.join(successful_exploits.keys())}")

    # Get post-exploit scripts
    post_exploit_scripts = get_post_exploit_scripts()
    if not post_exploit_scripts:
        logger.warning("No post-exploit scripts found. Creating basic scripts...")
        # Create basic post-exploit scripts here if needed

    # Map services to scripts
    services = set(successful_exploits.keys())
    script_map = map_services_to_post_exploit_scripts(services)
    
    scripts_to_run = []
    for svc, scripts in script_map.items():
        if svc in successful_exploits:
            for script in scripts:
                scripts_to_run.append((script, svc, successful_exploits[svc]))
    
    if not scripts_to_run:
        logger.error(f"No post-exploit scripts found for successful services: {', '.join(services)}")
        sys.exit(1)

    # Run post-exploit scripts sequentially
    logger.info(f"Running {len(scripts_to_run)} post-exploit scripts for {args.target}")
    results = []
    
    for script_path, service, exploit_data in scripts_to_run:
        logger.info(f"Starting {script_path.name} for {service}...")
        try:
            result = run_post_exploit_script(
                script_path,
                args.target,
                service,
                exploit_data,
                args.attacker_ip,
                args.attacker_port
            )
            results.append(result)
            logger.info(f"Completed {result['script']}: {'Success' if result['success'] else 'Failed'}")
        except Exception as e:
            logger.error(f"Error running {script_path.name}: {e}")
            results.append({
                "script": script_path.stem,
                "service": service,
                "output": str(e),
                "success": False,
                "metadata": {},
                "report": "",
                "exploit_data": exploit_data
            })

    # Save summary
    summary_content = aggregate_post_exploit_results(args.target, results)
    with SUMMARY.open("w", encoding='utf-8') as f:
        f.write(summary_content)
    logger.info(f"Post-exploitation summary written to {SUMMARY}")

    # Save metadata
    post_exploit_metadata = {
        "target": args.target,
        "timestamp": datetime.now().isoformat(),
        "results": []
    }
    
    # Convert results to JSON-serializable format
    for result in results:
        serializable_result = {
            "script": result["script"],
            "service": result["service"],
            "output": result["output"],
            "success": result["success"],
            "metadata": result.get("metadata", result.get("post_exploit_data", {})),
            "report": result.get("report", ""),
            "exploit_data": {
                "port": result["exploit_data"].get("port", "unknown"),
                "exploits": result["exploit_data"].get("exploits", [])
            }
        }
        post_exploit_metadata["results"].append(serializable_result)
    
    with POST_EXPLOIT_METADATA.open("w", encoding='utf-8') as f:
        json.dump(post_exploit_metadata, f, indent=2)
    logger.info(f"Post-exploitation metadata saved to {POST_EXPLOIT_METADATA}")

if __name__ == "__main__":
    main() 